<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CanonStack Scribe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #2d2d2d;
            line-height: 1.4;
            font-size: 14px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 12px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .layout-container {
            display: flex;
            flex: 1;
            gap: 8px;
            overflow: hidden;
            min-height: 0; /* allow children to shrink and scroll */
            height: 100%;
        }

        .layout-sidebar {
            width: 40px;
            background: #f8f8f8;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px;
            gap: 8px;
        }

        .layout-icon {
            width: 32px;
            height: 32px;
            border: 1px solid #c0c0c0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: white;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .layout-icon:hover {
            background: #e8f4fd;
            border-color: #4a90e2;
        }

        .layout-icon.active {
            background: #4a90e2;
            color: white;
            border-color: #4a90e2;
        }

        .main-layout {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* critical for nested scrolling */
            height: 100%;
        }

        .draft-panel {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .draft-header {
            background: #f8f8f8;
            border-bottom: 1px solid #d0d0d0;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .draft-title {
            font-weight: 600;
            font-size: 14px;
            color: #2d2d2d;
        }

        .draft-textarea {
            flex: 1;
            border: none;
            padding: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
            background: white;
        }

        .draft-textarea:focus {
            outline: none;
        }

        .copy-options {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .copy-btn {
            padding: 2px 6px;
            font-size: 10px;
            background: #f0f0f0;
            border: 1px solid #c0c0c0;
            border-radius: 2px;
            cursor: pointer;
            color: #666;
        }

        .copy-btn:hover {
            background: #e0e0e0;
            color: #333;
        }

        .header {
            background: #3a3a3a;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
        }

        .header p {
            font-size: 12px;
            color: #bbb;
        }

        .toolbar {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            display: flex;
            gap: 12px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .search-section {
            display: flex;
            gap: 8px;
            flex: 1;
            align-items: flex-start;
        }
        
        .search-section .search-btn {
            align-self: flex-start;
            margin-top: 0;
        }
        
        .toolbar-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: stretch;
        }

        .search-input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            font-size: 14px;
            min-width: 200px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.5;
            resize: vertical;
            min-height: 60px;
            max-height: 200px;
        }

        .search-input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 3px rgba(74, 144, 226, 0.3);
        }

        .search-btn {
            padding: 6px 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
        }

        .search-btn:hover:not(:disabled) {
            background: #357abd;
        }

        .search-btn:disabled {
            background: #999;
            cursor: not-allowed;
        }

        .source-selector {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .source-selector label {
            font-size: 12px;
            font-weight: 500;
            color: #555;
        }

        .source-dropdown {
            padding: 4px 8px;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            font-size: 13px;
            background: white;
            min-width: 150px;
        }

        .history-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: stretch;
            justify-content: flex-start;
        }
        
        .history-controls .history-btn {
            align-self: stretch;
        }

        .history-btn {
            padding: 6px 12px;
            background: #f8f8f8;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            color: #555;
        }

        .history-btn:hover {
            background: #e8e8e8;
        }

        .history-btn.active {
            background: #4a90e2;
            color: white;
            border-color: #4a90e2;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 12px;
            color: #666;
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            border-top-color: #4a90e2;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr 200px;
            gap: 8px;
            flex: 1 1 0;
            min-height: 0;
            align-items: stretch;
            height: 100%; /* ensure panels receive height */
        }

        .panel {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: 100%;
            max-height: 100%;
        }

        .panel-header {
            background: #f0f0f0;
            border-bottom: 1px solid #d0d0d0;
            padding: 6px 10px;
            font-size: 13px;
            font-weight: 600;
            color: #333;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 32px; /* Ensure consistent height */
            height: 32px; /* Fixed height to match Search History header */
        }

        .filter-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 11px;
            margin: 0;
            vertical-align: middle;
            font-weight: 500;
            cursor: pointer;
        }

        .filter-btn:hover {
            background: #357abd;
        }

        .filter-tray {
            background: #f8f8f8;
            border-bottom: 1px solid #d0d0d0;
            padding: 12px;
            flex-shrink: 0;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: visible;
            position: relative;
        }

        .filter-section {
            margin-bottom: 16px;
            position: relative;
        }

        .filter-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 120px;
            overflow-y: auto;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .checkbox-item input[type="checkbox"] {
            cursor: pointer;
        }

        .checkbox-item label {
            cursor: pointer;
            flex: 1;
            color: #555;
        }

        .autocomplete-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            font-size: 12px;
            box-sizing: border-box;
        }

        .autocomplete-input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 3px rgba(74, 144, 226, 0.3);
        }

        .autocomplete-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: none;
            margin-top: 2px;
            width: 100%;
            box-sizing: border-box;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .autocomplete-item:hover {
            background: #f0f0f0;
        }

        .autocomplete-item.concept-header {
            font-weight: 600;
            background: #e8f4f8;
            color: #2d5aa0;
        }

        .autocomplete-item.concept-related {
            padding-left: 24px;
            color: #666;
        }

        .selected-filters {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .filter-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #4a90e2;
            color: white;
            border-radius: 3px;
            font-size: 11px;
        }

        .filter-tag .remove-btn {
            cursor: pointer;
            font-weight: bold;
            opacity: 0.8;
        }

        .filter-tag .remove-btn:hover {
            opacity: 1;
        }

        .filter-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #d0d0d0;
        }

        .filter-actions .search-btn {
            flex: 1;
        }

        .panel-content {
            padding: 10px 10px 28px; /* extra bottom padding so last line isn't clipped */
            flex: 1 1 auto;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            max-height: 100%;
            box-sizing: border-box;
            scroll-padding-bottom: 28px; /* ensure scroll snaps allow viewing padded end */
            -webkit-overflow-scrolling: touch;
            position: relative;
            overscroll-behavior: contain;
        }

        .reasoning-section {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 12px;
        }

        .reasoning-title {
            font-weight: 600;
            color: #555;
            margin-bottom: 4px;
            font-size: 12px;
            text-transform: uppercase;
        }

        .reasoning-text {
            color: #666;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            background: #fafafa;
            padding: 8px;
            border-radius: 3px;
            border: 1px solid #e8e8e8;
        }

        .summary {
            font-size: 14px;
            line-height: 1.5;
            color: #2d2d2d;
        }

        .summary p {
            margin-bottom: 10px;
        }

        .summary h1, .summary h2, .summary h3, .summary h4 {
            margin-top: 16px;
            margin-bottom: 12px;
            font-weight: 600;
            color: #1a1a1a;
            line-height: 1.3;
        }

        .summary h1 {
            font-size: 22px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 8px;
            margin-top: 0;
        }

        .summary h2 {
            font-size: 20px;
            margin-top: 20px;
        }

        .summary h3 {
            font-size: 18px;
            margin-top: 16px;
        }

        .summary h4 {
            font-size: 16px;
            margin-top: 14px;
        }

        .summary strong, .summary b {
            font-weight: 600;
            color: #1a1a1a;
        }

        .summary ol, .summary ul {
            margin: 12px 0;
            padding-left: 24px;
        }

        .summary li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .summary ol {
            list-style-type: decimal;
        }

        .summary ul {
            list-style-type: disc;
        }

        .citation {
            background: #e6f3ff;
            color: #0066cc;
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .citation:hover {
            background: #cce7ff;
        }

        .source-item {
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 6px;
            transition: all 0.2s;
            font-size: 13px;
        }

        .source-item:hover {
            border-color: #4a90e2;
            box-shadow: 0 1px 3px rgba(74, 144, 226, 0.2);
        }

        .source-item.highlighted {
            border-color: #4a90e2;
            background: #f0f7ff;
            box-shadow: 0 2px 6px rgba(74, 144, 226, 0.3);
        }

        .source-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .source-number {
            background: #4a90e2;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
        }

        .source-title {
            font-weight: 600;
            color: #2d2d2d;
            font-size: 13px;
        }

        .source-meta {
            color: #666;
            font-size: 11px;
            margin-bottom: 6px;
        }

        .source-text {
            color: #555;
            line-height: 1.4;
            font-size: 12px;
        }

        .source-relevance {
            background: #f0f8ff;
            border-left: 2px solid #4a90e2;
            padding: 6px;
            margin-top: 6px;
            font-size: 11px;
            color: #2d5aa0;
        }

        .metadata-tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .metadata-tooltip .tooltip-content {
            visibility: hidden;
            width: 280px;
            background-color: #2d2d2d;
            color: #f0f0f0;
            text-align: left;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            top: 100%;
            right: 0;
            margin-top: 4px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 11px;
            line-height: 1.3;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .metadata-tooltip .tooltip-content::after {
            content: "";
            position: absolute;
            bottom: 100%;
            right: 15px;
            border-width: 4px;
            border-style: solid;
            border-color: transparent transparent #2d2d2d transparent;
        }

        .metadata-tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        .metadata-section {
            margin-bottom: 6px;
        }

        .metadata-label {
            font-weight: 600;
            color: #aaa;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metadata-values {
            color: #ddd;
            margin-top: 2px;
        }

        .history-panel {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
        }

        .history-item {
            padding: 6px 8px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 12px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .history-item:hover {
            background: #f5f5f5;
        }

        .delete-draft-btn {
            background: transparent;
            border: none;
            color: #999;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .delete-draft-btn:hover {
            background: #ff6b6b;
            color: white;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-query {
            font-weight: 500;
            color: #2d2d2d;
            margin-bottom: 2px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .history-meta {
            color: #666;
            font-size: 11px;
        }

        .error {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            color: #c53030;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-size: 13px;
        }

        .no-results {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 13px;
        }

        .source-checkbox {
            margin-right: 6px;
            transform: scale(0.9);
        }

        .source-list-item {
            display: flex;
            align-items: center;
            padding: 4px 0;
            font-size: 12px;
        }

        .source-list-item label {
            cursor: pointer;
            display: flex;
            align-items: center;
            width: 100%;
        }

        .source-count {
            color: #666;
            font-size: 11px;
            margin-left: auto;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
            
            .history-panel {
                max-height: 200px;
            }
        }

        .search-history-list {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        
        #searchHistorySection {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .clear-history-btn {
            padding: 4px 8px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            margin: 0;
            vertical-align: middle;
        }

        .clear-history-btn:hover {
            background: #ff5252;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>CanonStack Scribe</h1>
                <p>Your theological research stack</p>
            </div>
        </div>

        <div class="toolbar">
            <div class="search-section">
                <textarea 
                    class="search-input" 
                    id="queryInput" 
                    placeholder="Enter your theological question or research topic... (You can paste paragraphs from sermons, longer queries, etc.)"
                    rows="3"
                ></textarea>
            </div>
            
            <div class="toolbar-buttons">
                <button class="search-btn" id="searchBtn" onclick="performSearch()">Research</button>
                <button class="history-btn" id="saveSearchBtn" onclick="saveCurrentSearch()" disabled>Save</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span style="margin-left: 8px;">Analyzing query and searching sources...</span>
        </div>

        <div class="layout-container" id="layoutContainer" style="display: flex;">
            <div class="main-layout">
                <!-- Research Layout -->
                <div class="main-content" id="researchLayout" style="display: grid;">
                    <div class="panel">
                        <div class="panel-header">Research Summary</div>
                        <div class="panel-content" id="researchContent">
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; min-height: 200px;">
                                <button class="search-btn" id="generateSummaryBtn" onclick="generateSummary()" style="padding: 12px 24px; font-size: 14px;">Get AI Summary</button>
                            </div>
                        </div>
                    </div>

                    <div class="panel">
                        <div class="panel-header">
                            Sources & Citations
                            <button class="filter-btn" id="filterBtn" onclick="toggleFilterTray()" title="Toggle Filters">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M2 4h12M4 8h8M6 12h4"/>
                                </svg>
                                Filters
                            </button>
                        </div>
                        <div class="filter-tray" id="filterTray" style="display: none;">
                            <div class="filter-section">
                                <label class="filter-label">Source</label>
                                <div class="checkbox-group" id="sourceFilters"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Author</label>
                                <div class="checkbox-group" id="authorFilters"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Concept/Topic/Term</label>
                                <input type="text" class="autocomplete-input" id="conceptFilterInput" placeholder="Type to search concepts, topics, or terms..." oninput="handleConceptAutocomplete(event)" onkeydown="handleAutocompleteKeydown(event, 'concept')">
                                <div class="autocomplete-dropdown" id="conceptAutocomplete"></div>
                                <div class="selected-filters" id="selectedConcepts"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Discourse Elements</label>
                                <input type="text" class="autocomplete-input" id="discourseFilterInput" placeholder="Type to search discourse elements..." oninput="handleDiscourseAutocomplete(event)" onkeydown="handleAutocompleteKeydown(event, 'discourse')">
                                <div class="autocomplete-dropdown" id="discourseAutocomplete"></div>
                                <div class="selected-filters" id="selectedDiscourse"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Scripture References</label>
                                <input type="text" class="autocomplete-input" id="scriptureFilterInput" placeholder="Type to search scripture references..." oninput="handleScriptureAutocomplete(event)" onkeydown="handleAutocompleteKeydown(event, 'scripture')">
                                <div class="autocomplete-dropdown" id="scriptureAutocomplete"></div>
                                <div class="selected-filters" id="selectedScripture"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Named Entities</label>
                                <input type="text" class="autocomplete-input" id="entityFilterInput" placeholder="Type to search named entities..." oninput="handleEntityAutocomplete(event)" onkeydown="handleAutocompleteKeydown(event, 'entity')">
                                <div class="autocomplete-dropdown" id="entityAutocomplete"></div>
                                <div class="selected-filters" id="selectedEntities"></div>
                            </div>
                            <div class="filter-actions">
                                <button class="search-btn" onclick="applyFilters()">Apply Filters</button>
                                <button class="search-btn" onclick="clearFilters()" style="background: #6c757d;">Clear All</button>
                            </div>
                        </div>
                        <div class="panel-content" id="sourcesContent"></div>
                    </div>

                    <div class="panel history-panel">
                        <div class="panel-header">
                            Search History
                            <div style="display: flex; gap: 8px;">
                                <button class="clear-history-btn" onclick="clearSearchHistory()">Clear All</button>
                            </div>
                        </div>
                        <div class="panel-content" style="display: flex; flex-direction: column; min-height: 0;">
                            <div id="sourceSelectionSection" style="display: none;">
                                <div style="font-weight: 600; margin-bottom: 8px; font-size: 12px;">Select Sources:</div>
                                <div id="sourcesList"></div>
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                    <button class="history-btn" onclick="selectAllSources()">All</button>
                                    <button class="history-btn" onclick="selectNoSources()">None</button>
                                    <button class="history-btn" onclick="applySourceSelection()">Apply</button>
                                </div>
                            </div>
                            <div id="searchHistorySection" style="display: flex; flex-direction: column; flex: 1; min-height: 0; overflow: hidden;">
                                <div class="search-history-list" id="searchHistoryList" style="flex: 1; overflow-y: auto; min-height: 0;">
                                    <div class="no-results">No saved searches yet</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content" id="mainContent" style="display: none;">
            <div class="panel">
                <div class="panel-header">Research Summary</div>
                <div class="panel-content" id="researchContent"></div>
            </div>

            <div class="panel">
                <div class="panel-header">Sources & Citations</div>
                <div class="panel-content" id="sourcesContent"></div>
            </div>

            <div class="panel history-panel" id="historyPanel" style="display: none;">
                <div class="panel-header">
                    Search History
                    <div style="display: flex; gap: 8px;">
                        <button class="clear-history-btn" onclick="clearSearchHistory()">Clear All</button>
                    </div>
                </div>
                <div class="panel-content" style="display: flex; flex-direction: column; min-height: 0;">
                    <div id="sourceSelectionSection" style="display: none;">
                        <div style="font-weight: 600; margin-bottom: 8px; font-size: 12px;">Select Sources:</div>
                        <div id="sourcesList"></div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                            <button class="history-btn" onclick="selectAllSources()">All</button>
                            <button class="history-btn" onclick="selectNoSources()">None</button>
                            <button class="history-btn" onclick="applySourceSelection()">Apply</button>
                        </div>
                    </div>
                    <div id="searchHistorySection" style="display: flex; flex-direction: column; flex: 1; min-height: 0; overflow: hidden;">
                        <div class="search-history-list" id="searchHistoryList" style="flex: 1; overflow-y: auto; min-height: 0;">
                            <div class="no-results">No saved searches yet</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentSources = [];
        let availableSources = [];
        let selectedSources = new Set();
        let searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');
        let draftHistory = JSON.parse(localStorage.getItem('draftHistory') || '[]');
        let currentSearchResult = null;
        let currentSearchId = null; // Track the ID of the current saved search
        let currentLayout = 'research';
        let currentDraftCitations = null;
        let draftAutosaveTimer = null;
        let currentDraftId = null; // Track which draft is currently being edited
        
        // Clean up old drafts that have full chunks stored (to avoid quota issues)
        // Migrate old format to new format (only store lightweight chunks, not full chunks with embeddings)
        let needsDraftMigration = false;
        for (let draft of draftHistory) {
            if (draft.citations) {
                // If it has chunk_ids but no chunks, that's the old format - skip (can't restore)
                if (draft.citations.chunk_ids && !draft.citations.chunks) {
                    // Old format with only IDs - can't restore chunks, but keep the draft
                    continue;
                }
                // If it has full chunks with embeddings, migrate to lightweight format
                if (draft.citations.chunks && Array.isArray(draft.citations.chunks) && draft.citations.chunks.length > 0) {
                    const firstChunk = draft.citations.chunks[0];
                    // Check if chunks have embeddings (old format)
                    if (firstChunk.embedding || (firstChunk.similarity_score !== undefined)) {
                        // Migrate to lightweight format
                        draft.citations.chunks = draft.citations.chunks.map(c => ({
                            id: c.id || c.get?.('id'),
                            text: c.text || '',
                            metadata: c.metadata || {},
                            source: c.source || '',
                            author: c.author || '',
                            structure_path: c.metadata?.structure_path || ''
                        }));
                        needsDraftMigration = true;
                    }
                }
            }
        }
        if (needsDraftMigration) {
            try {
                localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                console.log('Migrated old draft format to new format (removed full chunks)');
            } catch (e) {
                console.warn('Could not migrate drafts:', e);
            }
        }
        
        // Clean up old search history that has full chunks stored (to avoid quota issues)
        // Migrate old format to new format (only store lightweight chunks, not full chunks with embeddings)
        let needsSearchMigration = false;
        let needsSimilarityMigration = false;
        
        for (let search of searchHistory) {
            if (search.chunks && Array.isArray(search.chunks) && search.chunks.length > 0) {
                const firstChunk = search.chunks[0];
                // Check if chunks have embeddings (old format with full chunks)
                if (firstChunk.embedding || (firstChunk.similarity_score !== undefined)) {
                    // Migrate to lightweight format
                    search.chunks = search.chunks.map(c => ({
                        id: c.id || c.get?.('id'),
                        text: c.text || '',
                        metadata: c.metadata || {},
                        source: c.source || '',
                        author: c.author || '',
                        structure_path: c.metadata?.structure_path || '',
                        _chunk_index: c._chunk_index
                    }));
                    needsSearchMigration = true;
                }
            } else if (search.chunk_ids && !search.chunks) {
                // Old format with only IDs - can't restore chunks, but keep the search
                // Add empty chunks array for consistency
                search.chunks = [];
            }
            
            // Migrate similarity scores: clamp negative values to 0.0
            if (search.sources && Array.isArray(search.sources)) {
                for (const source of search.sources) {
                    // Update similarity_score field if it exists and is negative
                    if (source.similarity_score !== undefined && source.similarity_score < 0) {
                        source.similarity_score = Math.max(0.0, Math.min(1.0, source.similarity_score));
                        needsSimilarityMigration = true;
                    }
                    
                    // Update similarity score in relevance_explanation text
                    if (source.relevance_explanation) {
                        const similarityMatch = source.relevance_explanation.match(/\(similarity:\s*([-\d.]+)\)/);
                        if (similarityMatch) {
                            const oldSimilarity = parseFloat(similarityMatch[1]);
                            if (oldSimilarity < 0) {
                                const newSimilarity = Math.max(0.0, Math.min(1.0, oldSimilarity));
                                source.relevance_explanation = source.relevance_explanation.replace(
                                    /\(similarity:\s*[-\d.]+\)/,
                                    `(similarity: ${newSimilarity.toFixed(3)})`
                                );
                                needsSimilarityMigration = true;
                            }
                        }
                    }
                }
            }
        }
        
        if (needsSearchMigration || needsSimilarityMigration) {
            try {
                localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                if (needsSearchMigration) {
                    console.log('Migrated old search format to new format (removed full chunks)');
                }
                if (needsSimilarityMigration) {
                    console.log('Migrated similarity scores: clamped negative values to 0.0');
                }
            } catch (e) {
                console.warn('Could not migrate search history:', e);
            }
        }

        // Initialize the interface
        document.addEventListener('DOMContentLoaded', function() {
            loadAvailableSources();
            displaySearchHistory();
            displayDraftHistory();
            // Ensure the layout is visible on load
            try {
                document.getElementById('layoutContainer').style.display = 'flex';
                document.getElementById('researchLayout').style.display = 'grid';
            } catch (e) {
                console.warn('Layout init warning:', e);
            }
            
            // Handle Enter key in search textarea (Ctrl+Enter or Cmd+Enter to submit)
            document.getElementById('queryInput').addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    performSearch();
                }
            });
            
            // Draft functionality removed - autosave disabled
            // const draftTA = document.getElementById('draftTextarea');
            // if (draftTA) {
            //     draftTA.addEventListener('input', () => {
            //         scheduleDraftAutosave();
            //     });
            // }

            // Source dropdown removed - sources can be filtered via Filters button in Sources & Citations panel
        });

        // Auto-backup on page visibility change (safety net)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // Page is being hidden (tab switch, minimize, close, etc.)
                // Force immediate backup without debouncing
                if (searchHistory.length > 0) {
                    downloadSearchHistoryBackup();
                }
                if (draftHistory.length > 0) {
                    downloadDraftHistoryBackup();
                }
            }
        });

        function loadAvailableSources() {
            // Fetch available sources from API
            fetch('/api/sources')
                .then(response => response.json())
                .then(sources => {
                    availableSources = sources;
                    
                    // Initialize with all sources selected
                    selectedSources.clear();
                    availableSources.forEach(source => selectedSources.add(source.id));
                    
                    updateSourcesList();
                })
                .catch(error => {
                    console.error('Error loading sources:', error);
                    // Fallback: show error message
                    availableSources = [];
                    selectedSources.clear();
                    updateSourcesList();
                });
        }

        function updateSourcesList() {
            const sourcesList = document.getElementById('sourcesList');
            sourcesList.innerHTML = '';
            
            availableSources.forEach(source => {
                const item = document.createElement('div');
                item.className = 'source-list-item';
                item.innerHTML = `
                    <label>
                        <input type="checkbox" class="source-checkbox" 
                               ${selectedSources.has(source.id) ? 'checked' : ''} 
                               onchange="toggleSourceSelection('${source.id}')">
                        <span>${source.name}</span>
                        <span class="source-count">(${source.chunkCount})</span>
                    </label>
                `;
                sourcesList.appendChild(item);
            });
        }

        function showSourceSelection() {
            document.getElementById('sourceSelectionSection').style.display = 'block';
            document.getElementById('searchHistorySection').style.display = 'none';
            document.getElementById('historyPanel').style.display = 'block';
        }

        function hideSourceSelection() {
            document.getElementById('sourceSelectionSection').style.display = 'none';
            document.getElementById('searchHistorySection').style.display = 'block';
        }

        function toggleSourceSelection(sourceId) {
            if (selectedSources.has(sourceId)) {
                selectedSources.delete(sourceId);
            } else {
                selectedSources.add(sourceId);
            }
        }

        function selectAllSources() {
            selectedSources.clear();
            availableSources.forEach(source => selectedSources.add(source.id));
            updateSourcesList();
        }

        function selectNoSources() {
            selectedSources.clear();
            updateSourcesList();
        }

        function applySourceSelection() {
            // Source dropdown removed - no need to update dropdown value
        }


        function saveCurrentSearch() {
            if (!currentSearchResult) return;
            
            const searchId = Date.now();
            currentSearchId = searchId; // Track this search ID
            
            const searchEntry = {
                id: searchId,
                query: document.getElementById('queryInput').value.trim(),
                timestamp: new Date().toISOString(),
                summary: currentSearchResult.summary || null, // Include summary if it exists
                sources: currentSearchResult.sources_used,
                reasoning: currentSearchResult.reasoning_transparency,
                sourceSelection: Array.from(selectedSources),
                query_analysis: currentSearchResult.query_analysis || {}, // Store query analysis for future use
                // Store lightweight chunk data (text, metadata, source, author) but NOT embeddings
                chunks: currentSearchResult.chunks ? currentSearchResult.chunks.map(c => ({
                    id: c.id || c.get?.('id'),
                    text: c.text || '',
                    metadata: c.metadata || {},
                    source: c.source || '',
                    author: c.author || '',
                    structure_path: c.metadata?.structure_path || '',
                    _chunk_index: c._chunk_index
                })) : []
            };
            
            searchHistory.unshift(searchEntry);
            
            // Keep only last 20 searches to avoid quota issues
            if (searchHistory.length > 20) {
                searchHistory = searchHistory.slice(0, 20);
            }
            
            // Try to save, with error handling for quota issues
            try {
                localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                autoBackupSearchHistory();
            } catch (e) {
                if (e.name === 'QuotaExceededError' || e.message.includes('quota')) {
                    // If quota exceeded, try removing oldest searches
                    console.warn('localStorage quota exceeded, removing oldest searches');
                    while (searchHistory.length > 10) {
                        searchHistory.pop(); // Remove oldest
                    }
                    try {
                        localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                        autoBackupSearchHistory();
                        alert('Search saved, but some older searches were removed due to storage limits.');
                    } catch (e2) {
                        // Still failed - try with even fewer
                        searchHistory = searchHistory.slice(0, 5);
                        localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                        autoBackupSearchHistory();
                        alert('Search saved, but many older searches were removed due to storage limits.');
                    }
                } else {
                    throw e; // Re-throw if it's a different error
                }
            }
            
            displaySearchHistory();
            document.getElementById('saveSearchBtn').disabled = true;
        }

        function displaySearchHistory() {
            const historyList = document.getElementById('searchHistoryList');
            
            if (searchHistory.length === 0) {
                historyList.innerHTML = '<div class="no-results">No saved searches yet</div>';
                return;
            }
            
            historyList.innerHTML = searchHistory.map(entry => `
                <div class="history-item">
                    <div onclick="loadSearchFromHistory(${entry.id})" style="flex: 1; cursor: pointer;">
                        <div class="history-query">${entry.query}</div>
                        <div class="history-meta">
                            ${new Date(entry.timestamp).toLocaleDateString()} • ${entry.sources.length} sources
                        </div>
                    </div>
                    <button class="delete-draft-btn" onclick="event.stopPropagation(); deleteSearch(${entry.id})" title="Delete search">×</button>
                </div>
            `).join('');
        }

        function loadSearchFromHistory(searchId) {
            const entry = searchHistory.find(s => s.id === searchId);
            if (!entry) return;
            
            // Track this search ID so we can update it if summary is generated
            currentSearchId = searchId;
            
            // Restore the search
            document.getElementById('queryInput').value = entry.query;
            
            // Restore source selection
            selectedSources.clear();
            entry.sourceSelection.forEach(sourceId => selectedSources.add(sourceId));
            // Source dropdown removed - no need to update dropdown value
            
            // Prepare search result object with all necessary data for filtering
            const searchResult = {
                query: entry.query,
                summary: entry.summary || null, // Include summary if it exists
                sources_used: entry.sources,
                reasoning_transparency: entry.reasoning,
                chunks: entry.chunks || [], // Now contains lightweight chunk data with text
                query_analysis: entry.query_analysis || {}
            };
            
            // Set current search result BEFORE displaying so filters can work
            currentSearchResult = searchResult;
            
            // Display the saved results (this will show summary if it exists)
            displaySearchResults(searchResult);
            
            // Ensure only the new layout is visible
            document.getElementById('layoutContainer').style.display = 'flex';
            document.getElementById('researchLayout').style.display = 'grid';
            // Hide legacy container to avoid double panels
            const legacyMain = document.getElementById('mainContent');
            if (legacyMain) legacyMain.style.display = 'none';
            
            document.getElementById('saveSearchBtn').disabled = true;
        }

        function deleteSearch(searchId) {
            // Remove from history
            const index = searchHistory.findIndex(s => s.id === searchId);
            if (index !== -1) {
                searchHistory.splice(index, 1);
                localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                autoBackupSearchHistory();
                displaySearchHistory();
            }
        }

        function clearSearchHistory() {
            if (confirm('Are you sure you want to clear all search history?')) {
                searchHistory = [];
                localStorage.removeItem('searchHistory');
                displaySearchHistory();
            }
        }

        function saveDraft() {
            try {
                const textarea = document.getElementById('draftTextarea');
                if (!textarea) return; // Draft layout removed
                if (!textarea) {
                    console.error('Draft textarea not found');
                    alert('Error: Could not find draft textarea.');
                    return;
                }
                
                const draftText = textarea.value.trim();
                
                if (!draftText) {
                    alert('Please write some content before saving the draft.');
                    return;
                }
                
                // Check if we should update existing draft or create new one
                let draftEntry;
                let isUpdate = false;
                
                if (currentDraftId) {
                    // Update existing draft
                    const existingIndex = draftHistory.findIndex(d => d.id === currentDraftId);
                    if (existingIndex !== -1) {
                        draftEntry = draftHistory[existingIndex];
                        draftEntry.title = draftText.substring(0, 50) + (draftText.length > 50 ? '...' : '');
                        draftEntry.content = draftText;
                        draftEntry.date = new Date().toLocaleDateString();
                        draftEntry.wordCount = draftText.split(/\s+/).length;
                        // Store lightweight chunk data (text, metadata, source, author) but NOT embeddings
                        draftEntry.citations = currentDraftCitations ? {
                            sources_used: currentDraftCitations.sources_used || [],
                            // Store lightweight chunk data: text, id, metadata, source, author (but NOT embeddings)
                            chunks: currentDraftCitations.chunks ? currentDraftCitations.chunks.map(c => ({
                                id: c.id || c.get?.('id'),
                                text: c.text || '',
                                metadata: c.metadata || {},
                                source: c.source || '',
                                author: c.author || '',
                                structure_path: c.metadata?.structure_path || ''
                            })) : []
                        } : null;
                        // Move to top
                        draftHistory.splice(existingIndex, 1);
                        draftHistory.unshift(draftEntry);
                        isUpdate = true;
                    } else {
                        currentDraftId = null; // Draft was deleted, create new
                    }
                }
                
                if (!isUpdate) {
                    // Create new draft
                    draftEntry = {
                        id: Date.now(),
                        title: draftText.substring(0, 50) + (draftText.length > 50 ? '...' : ''),
                        content: draftText,
                        date: new Date().toLocaleDateString(),
                        wordCount: draftText.split(/\s+/).length,
                        // Store lightweight chunk data (text, metadata, source, author) but NOT embeddings
                        citations: currentDraftCitations ? {
                            sources_used: currentDraftCitations.sources_used || [],
                            // Store lightweight chunk data: text, id, metadata, source, author (but NOT embeddings)
                            chunks: currentDraftCitations.chunks ? currentDraftCitations.chunks.map(c => ({
                                id: c.id || c.get?.('id'),
                                text: c.text || '',
                                metadata: c.metadata || {},
                                source: c.source || '',
                                author: c.author || '',
                                structure_path: c.metadata?.structure_path || ''
                            })) : []
                        } : null
                    };
                    draftHistory.unshift(draftEntry);
                    currentDraftId = draftEntry.id;
                }
                
                // Limit to fewer drafts to avoid localStorage quota issues
                if (draftHistory.length > 20) {
                    draftHistory = draftHistory.slice(0, 20); // Keep only last 20 drafts
                }
                
                // Try to save, with error handling for quota issues
                try {
                    localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                    autoBackupDraftHistory();
                } catch (e) {
                    if (e.name === 'QuotaExceededError' || e.message.includes('quota')) {
                        // If quota exceeded, try removing oldest drafts
                        console.warn('localStorage quota exceeded, removing oldest drafts');
                        while (draftHistory.length > 10) {
                            draftHistory.pop(); // Remove oldest
                        }
                        try {
                            localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                            autoBackupDraftHistory();
                            alert('Draft saved, but some older drafts were removed due to storage limits.');
                        } catch (e2) {
                            // Still failed - try with even fewer
                            draftHistory = draftHistory.slice(0, 5);
                            localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                            autoBackupDraftHistory();
                            alert('Draft saved, but many older drafts were removed due to storage limits.');
                        }
                    } else {
                        throw e; // Re-throw if it's a different error
                    }
                }
                
                // Ensure draftHistoryList element exists before calling displayDraftHistory
                const historyList = document.getElementById('draftHistoryList');
                if (historyList) {
                    displayDraftHistory();
                } else {
                    console.warn('draftHistoryList element not found, but draft was saved to localStorage');
                }
                
                // Update autosave snapshot
                persistDraftAutosave();
                
                // Show feedback
                const btn = document.getElementById('saveDraftBtn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = isUpdate ? 'Updated!' : 'Saved!';
                    btn.style.background = '#d4edda';
                    btn.style.color = '#155724';
                    
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#4a90e2';
                        btn.style.color = 'white';
                    }, 1000);
                }
            } catch (error) {
                console.error('Error saving draft:', error);
                alert('Error saving draft: ' + error.message);
            }
        }

        function displayDraftHistory() {
            try {
                const historyList = document.getElementById('draftHistoryList');
                if (!historyList) {
                    console.warn('draftHistoryList element not found');
                    return;
                }
                
                if (!draftHistory || draftHistory.length === 0) {
                    historyList.innerHTML = '<div class="no-results">No saved drafts yet</div>';
                    return;
                }
                
                historyList.innerHTML = draftHistory.map(draft => {
                    const title = (draft.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const date = draft.date || 'Unknown date';
                    const wordCount = draft.wordCount || 0;
                    const sourceCount = draft.citations && draft.citations.sources_used ? draft.citations.sources_used.length : 0;
                    return `
                        <div class="history-item">
                            <div onclick="loadDraft(${draft.id})" style="flex: 1; cursor: pointer;">
                                <div class="history-title">${title}</div>
                                <div class="history-meta">${date} • ${wordCount} words${sourceCount > 0 ? ` • ${sourceCount} sources` : ''}</div>
                            </div>
                            <button class="delete-draft-btn" onclick="event.stopPropagation(); deleteDraft(${draft.id})" title="Delete draft">×</button>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Error displaying draft history:', error);
            }
        }

        function loadDraft(draftId) {
            const draft = draftHistory.find(d => d.id === draftId);
            if (!draft) return;
            
            const draftTA = document.getElementById('draftTextarea');
            if (!draftTA) return; // Draft layout removed
            draftTA.value = draft.content;
            currentDraftId = draftId; // Set current draft ID so we can update it
            
            if (draft.citations) {
                // Restore citations with lightweight chunk data
                currentDraftCitations = {
                    sources_used: draft.citations.sources_used || [],
                    chunks: draft.citations.chunks || [] // Now contains lightweight chunk data (text, metadata, etc.)
                };
                displayDraftSearchResults(currentDraftCitations);
            } else {
                currentDraftCitations = null;
                const draftSources = document.getElementById('draftSourcesContent');
            if (!draftSources) return; // Draft layout removed
            draftSources.innerHTML = '';
            }
            
            // Draft functionality removed - keeping function stub for compatibility
            scheduleDraftAutosave();
        }

        function deleteDraft(draftId) {
            // Remove from history
            const index = draftHistory.findIndex(d => d.id === draftId);
            if (index !== -1) {
                draftHistory.splice(index, 1);
                localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                autoBackupDraftHistory();
                displayDraftHistory();
                
                // If this was the current draft being edited, clear it
                if (currentDraftId === draftId) {
                    const draftTA = document.getElementById('draftTextarea');
            if (!draftTA) return; // Draft layout removed
            draftTA.value = '';
                    currentDraftId = null;
                    currentDraftCitations = null;
                    const draftSources = document.getElementById('draftSourcesContent');
            if (!draftSources) return; // Draft layout removed
            draftSources.innerHTML = '';
                    localStorage.removeItem('draftAutosave');
                }
            }
        }

        function newDraft() {
            // Clear current draft state
            const draftTA = document.getElementById('draftTextarea');
            if (!draftTA) return; // Draft layout removed
            draftTA.value = '';
            currentDraftId = null;
            currentDraftCitations = null;
            const draftSources = document.getElementById('draftSourcesContent');
            if (!draftSources) return; // Draft layout removed
            draftSources.innerHTML = '';
            
            // Clear autosave
            localStorage.removeItem('draftAutosave');
            
            // Draft functionality removed - keeping function stub for compatibility
        }

        function clearDraftHistory() {
            if (confirm('Are you sure you want to clear all draft history?')) {
                draftHistory = [];
                localStorage.removeItem('draftHistory');
                displayDraftHistory();
            }
        }

        // Auto-backup functionality
        let searchHistoryBackupTimer = null;
        let draftHistoryBackupTimer = null;
        let lastSearchBackupTime = 0;
        let lastDraftBackupTime = 0;
        const BACKUP_DEBOUNCE_MS = 60000; // Only backup once per minute max

        function autoBackupSearchHistory() {
            if (searchHistory.length === 0) return; // Don't backup empty history
            
            const now = Date.now();
            if (now - lastSearchBackupTime < BACKUP_DEBOUNCE_MS) {
                // Schedule backup for later
                if (searchHistoryBackupTimer) clearTimeout(searchHistoryBackupTimer);
                searchHistoryBackupTimer = setTimeout(() => {
                    downloadSearchHistoryBackup();
                }, BACKUP_DEBOUNCE_MS - (now - lastSearchBackupTime));
                return;
            }
            
            downloadSearchHistoryBackup();
        }

        function autoBackupDraftHistory() {
            if (draftHistory.length === 0) return; // Don't backup empty history
            
            const now = Date.now();
            if (now - lastDraftBackupTime < BACKUP_DEBOUNCE_MS) {
                // Schedule backup for later
                if (draftHistoryBackupTimer) clearTimeout(draftHistoryBackupTimer);
                draftHistoryBackupTimer = setTimeout(() => {
                    downloadDraftHistoryBackup();
                }, BACKUP_DEBOUNCE_MS - (now - lastDraftBackupTime));
                return;
            }
            
            downloadDraftHistoryBackup();
        }

        function downloadSearchHistoryBackup() {
            try {
                // Send backup to server instead of downloading
                fetch('/api/backup/search-history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ history: searchHistory })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log(`Backup saved: ${data.filename}`);
                        lastSearchBackupTime = Date.now();
                    } else {
                        console.error('Backup failed:', data.error);
                    }
                })
                .catch(error => {
                    console.error('Error backing up search history:', error);
                });
            } catch (e) {
                console.error('Error auto-backing up search history:', e);
            }
        }

        function downloadDraftHistoryBackup() {
            try {
                // Send backup to server instead of downloading
                fetch('/api/backup/draft-history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ history: draftHistory })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log(`Backup saved: ${data.filename}`);
                        lastDraftBackupTime = Date.now();
                    } else {
                        console.error('Backup failed:', data.error);
                    }
                })
                .catch(error => {
                    console.error('Error backing up draft history:', error);
                });
            } catch (e) {
                console.error('Error auto-backing up draft history:', e);
            }
        }


        function scheduleDraftAutosave() {
            if (draftAutosaveTimer) clearTimeout(draftAutosaveTimer);
            draftAutosaveTimer = setTimeout(() => {
                persistDraftAutosave();
            }, 800);
        }

        function persistDraftAutosave() {
            try {
                const content = document.getElementById('draftTextarea').value.trim();
                
                // Only autosave if there's actual content and we have a currentDraftId
                if (!content || !currentDraftId) {
                    // Just store to autosave key for session persistence (not restored on page load)
                    const snapshot = {
                        content,
                        citations: currentDraftCitations,
                        timestamp: Date.now(),
                        draftId: currentDraftId
                    };
                    localStorage.setItem('draftAutosave', JSON.stringify(snapshot));
                    return;
                }
                
                // Update existing draft if we have a currentDraftId
                const existingIndex = draftHistory.findIndex(d => d.id === currentDraftId);
                if (existingIndex !== -1) {
                    const draft = draftHistory[existingIndex];
                    draft.content = content;
                    draft.title = content.substring(0, 50) + (content.length > 50 ? '...' : '');
                    draft.wordCount = content.split(/\s+/).length;
                    draft.citations = currentDraftCitations ? {
                        sources_used: currentDraftCitations.sources_used || [],
                        // Store lightweight chunk data: text, id, metadata, source, author (but NOT embeddings)
                        chunks: currentDraftCitations.chunks ? currentDraftCitations.chunks.map(c => ({
                            id: c.id || c.get?.('id'),
                            text: c.text || '',
                            metadata: c.metadata || {},
                            source: c.source || '',
                            author: c.author || '',
                            structure_path: c.metadata?.structure_path || ''
                        })) : []
                    } : null;
                    // Keep in place (don't move to top on autosave)
                    localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                    autoBackupDraftHistory();
                } else {
                    currentDraftId = null; // Draft was deleted
                }
            } catch (e) {
                console.error('Autosave error:', e);
            }
        }

        function switchLayout(layout) {
            currentLayout = layout;
            
            // Update layout icons
            document.getElementById('researchIcon').classList.toggle('active', layout === 'research');
            document.getElementById('draftIcon').classList.toggle('active', layout === 'draft');
            
            // Show/hide layouts
            if (layout === 'research') {
                document.getElementById('researchLayout').style.display = 'grid';
                document.getElementById('researchLayout').style.gridTemplateColumns = '2fr 1fr 200px';
                document.getElementById('draftLayout').style.display = 'none';
            } else if (layout === 'draft') {
                document.getElementById('draftLayout').style.display = 'grid';
                document.getElementById('draftLayout').style.gridTemplateColumns = '2fr 1fr 200px';
                document.getElementById('researchLayout').style.display = 'none';
            }
            
            // Show layout container
            document.getElementById('layoutContainer').style.display = 'flex';
            
            // Hide old main content if it exists
            document.getElementById('mainContent').style.display = 'none';
        }

        function findCitationsForDraft() {
            const textarea = document.getElementById('draftTextarea');
            const text = textarea.value;
            const cursorPos = textarea.selectionStart;
            
            if (!text.trim()) {
                alert('Please write some content first before searching for citations.');
                return;
            }
            
            // Extract context around cursor (5 sentences) and get position info
            const contextResult = extractContextAroundCursor(text, cursorPos);
            
            if (!contextResult.context || !contextResult.context.trim()) {
                alert('Could not extract enough context around cursor position.');
                return;
            }
            
            // Highlight the context text in the textarea
            if (contextResult.startPos !== undefined && contextResult.endPos !== undefined) {
                // Set selection to highlight the context
                textarea.focus();
                textarea.setSelectionRange(contextResult.startPos, contextResult.endPos);
                
                // Store the highlight info so we can clear it later if needed
                textarea.dataset.highlightedContext = 'true';
                textarea.dataset.highlightStart = contextResult.startPos;
                textarea.dataset.highlightEnd = contextResult.endPos;
            }
            
            // Show loading
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            
            // Perform context search
            fetch('/api/search-context', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    context_text: contextResult.context,
                    selected_sources: Array.from(selectedSources)
                })
            })
            .then(response => response.json())
            .then(data => {
                displayDraftSearchResults(data);
                currentDraftCitations = data;
                scheduleDraftAutosave();
            })
            .catch(error => {
                console.error('Context search error:', error);
                const draftSources = document.getElementById('draftSourcesContent');
            if (!draftSources) return; // Draft layout removed
            draftSources.innerHTML = `
                    <div class="error">Error: ${error.message}</div>
                `;
            })
            .finally(() => {
                loading.style.display = 'none';
            });
        }

        function extractContextAroundCursor(text, cursorPos) {
            // Find sentence boundaries using regex
            const sentenceRegex = /[.!?]+(?:\s+|$)/g;
            const sentences = [];
            const sentencePositions = [];
            let lastIndex = 0;
            let match;
            
            // Find all sentence boundaries
            while ((match = sentenceRegex.exec(text)) !== null) {
                const sentenceEnd = match.index + match[0].length;
                sentences.push(text.substring(lastIndex, sentenceEnd));
                sentencePositions.push({
                    start: lastIndex,
                    end: sentenceEnd
                });
                lastIndex = sentenceEnd;
            }
            
            // Add the last sentence if there's text after the last punctuation
            if (lastIndex < text.length) {
                sentences.push(text.substring(lastIndex));
                sentencePositions.push({
                    start: lastIndex,
                    end: text.length
                });
            }
            
            if (sentences.length === 0) {
                return { context: '', startPos: 0, endPos: 0 };
            }
            
            // Find which sentence the cursor is in
            let currentSentenceIndex = 0;
            for (let i = 0; i < sentencePositions.length; i++) {
                if (cursorPos >= sentencePositions[i].start && cursorPos <= sentencePositions[i].end) {
                    currentSentenceIndex = i;
                    break;
                }
            }
            
            // Extract 2 sentences before, current sentence, and 2 sentences after
            const startIndex = Math.max(0, currentSentenceIndex - 2);
            const endIndex = Math.min(sentences.length, currentSentenceIndex + 3);
            
            const startPos = sentencePositions[startIndex].start;
            const endPos = sentencePositions[endIndex - 1].end;
            
            // Extract context and trim for API, but keep original positions for highlighting
            let contextText = text.substring(startPos, endPos);
            // Trim whitespace but track how much we trimmed for accurate highlighting
            const originalLength = contextText.length;
            const trimmedText = contextText.trim();
            const trimmedStart = contextText.length - contextText.replace(/^\s+/, '').length;
            const trimmedEnd = originalLength - trimmedStart - trimmedText.length;
            const actualStartPos = startPos + trimmedStart;
            const actualEndPos = endPos - trimmedEnd;
            contextText = trimmedText;
            
            return {
                context: contextText,
                startPos: actualStartPos,
                endPos: actualEndPos
            };
        }

        function displayDraftSearchResults(data) {
            const sourcesContent = document.getElementById('draftSourcesContent');
            if (!sourcesContent) return; // Draft layout removed
            
            // Store sources for citation handling
            currentSources = data.sources_used || [];
            currentDraftCitations = data;
            
            // Display sources with copy options
            let sourcesHtml = '';
            if (currentSources.length > 0) {
                sourcesHtml = currentSources.map((source, index) => {
                    const chunk = data.chunks ? data.chunks[index] : null;
                    // Build metadata tooltip
                    const metadata = chunk ? (chunk.metadata || {}) : {};
                    let tooltipContent = '';
                    
                    if (metadata.topics && metadata.topics.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Topics</div><div class="metadata-values">${metadata.topics.join(', ')}</div></div>`;
                    }
                    if (metadata.concepts && metadata.concepts.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Concepts</div><div class="metadata-values">${metadata.concepts.join(', ')}</div></div>`;
                    }
                    if (metadata.terms && metadata.terms.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Terms</div><div class="metadata-values">${metadata.terms.join(', ')}</div></div>`;
                    }
                    if (metadata.discourse_elements && metadata.discourse_elements.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Discourse Elements</div><div class="metadata-values">${metadata.discourse_elements.join(', ')}</div></div>`;
                    }
                    if (metadata.scripture_references && metadata.scripture_references.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Scripture References</div><div class="metadata-values">${metadata.scripture_references.join(', ')}</div></div>`;
                    }
                    if (metadata.named_entities && metadata.named_entities.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Named Entities</div><div class="metadata-values">${metadata.named_entities.join(', ')}</div></div>`;
                    }
                    if (metadata.structure_path) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Location</div><div class="metadata-values">${metadata.structure_path}</div></div>`;
                    }
                    
                    const chunkText = chunk ? chunk.text : '';
                    const citationText = `(${source.source || 'Unknown'}, ${source.author || 'Unknown'})`;
                    const encodedText = encodeURIComponent(chunkText);
                    const encodedCitation = encodeURIComponent(citationText);
                    
                    return `
                        <div class="source-item" id="source-${source.number}">
                            <div class="source-header">
                                <div class="source-number">${source.number}</div>
                                <div class="source-title">${source.source || 'Unknown'}</div>
                                ${tooltipContent ? `
                                <div class="metadata-tooltip">
                                    <span style="cursor: help; color: #666;">ⓘ</span>
                                    <div class="tooltip-content">${tooltipContent}</div>
                                </div>
                                ` : ''}
                            </div>
                            <div class="source-meta">
                                <strong>Author:</strong> ${source.author || 'Unknown'}<br>
                                <strong>Location:</strong> ${(source.location || 'Unknown').replace(/^\[\[/, '').replace(/\]\]$/, '')}
                            </div>
                            <div class="source-text">${chunkText || 'Text not available'}</div>
                            ${source.relevance_explanation ? `
                                <div class="source-relevance">
                                    <strong>Why this source:</strong> ${source.relevance_explanation}
                                </div>
                            ` : source.relevance ? `<div class="source-relevance"><strong>Relevance:</strong> ${source.relevance}</div>` : ''}
                            <div class="copy-options">
                                <button class="copy-btn" data-text="${encodedText}" onclick="copyToClipboard(event)">Copy Text</button>
                                <button class="copy-btn" data-text="${encodedCitation}" onclick="copyToClipboard(event)">Copy Citation</button>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                sourcesHtml = '<div class="no-results">No sources found</div>';
            }
            
            sourcesContent.innerHTML = sourcesHtml;
            scheduleDraftAutosave();
        }

        // Filter functionality
        let filterOptions = null;
        let selectedFilters = {
            sources: [],
            authors: [],
            concepts: [],
            topics: [],
            terms: [],
            discourse_elements: [],
            scripture_references: [],
            named_entities: []
        };

        async function loadFilterOptions() {
            try {
                const response = await fetch('/api/filter-options');
                if (response.ok) {
                    filterOptions = await response.json();
                    populateFilters();
                } else {
                    console.error('Failed to load filter options');
                }
            } catch (error) {
                console.error('Error loading filter options:', error);
            }
        }

        function populateFilters() {
            if (!filterOptions) return;

            // Populate source checkboxes
            const sourceContainer = document.getElementById('sourceFilters');
            sourceContainer.innerHTML = filterOptions.sources.map(source => `
                <div class="checkbox-item">
                    <input type="checkbox" id="source-${source.replace(/[^a-zA-Z0-9]/g, '_')}" value="${source}" onchange="updateSourceFilter('${source}', this.checked)">
                    <label for="source-${source.replace(/[^a-zA-Z0-9]/g, '_')}">${source}</label>
                </div>
            `).join('');

            // Populate author checkboxes
            const authorContainer = document.getElementById('authorFilters');
            authorContainer.innerHTML = filterOptions.authors.map(author => `
                <div class="checkbox-item">
                    <input type="checkbox" id="author-${author.replace(/[^a-zA-Z0-9]/g, '_')}" value="${author}" onchange="updateAuthorFilter('${author}', this.checked)">
                    <label for="author-${author.replace(/[^a-zA-Z0-9]/g, '_')}">${author}</label>
                </div>
            `).join('');
        }

        function updateSourceFilter(source, checked) {
            if (checked) {
                if (!selectedFilters.sources.includes(source)) {
                    selectedFilters.sources.push(source);
                }
            } else {
                selectedFilters.sources = selectedFilters.sources.filter(s => s !== source);
            }
        }

        function updateAuthorFilter(author, checked) {
            if (checked) {
                if (!selectedFilters.authors.includes(author)) {
                    selectedFilters.authors.push(author);
                }
            } else {
                selectedFilters.authors = selectedFilters.authors.filter(a => a !== author);
            }
        }

        function toggleFilterTray() {
            const tray = document.getElementById('filterTray');
            const isVisible = tray.style.display !== 'none';
            tray.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible && !filterOptions) {
                loadFilterOptions();
            }
        }

        function handleConceptAutocomplete(event) {
            const input = event.target.value.toLowerCase();
            const dropdown = document.getElementById('conceptAutocomplete');
            const inputEl = event.target;
            
            if (!filterOptions || !input) {
                dropdown.classList.remove('show');
                return;
            }

            const matches = [];
            
            // Search concepts, topics, and terms
            for (const [concept, related] of Object.entries(filterOptions.concept_suggestions)) {
                const conceptLower = concept.toLowerCase();
                if (conceptLower.includes(input)) {
                    matches.push({ type: 'concept', value: concept, display: concept, related: related });
                }
                
                // Also check related topics and terms
                for (const topic of related.topics || []) {
                    if (topic.toLowerCase().includes(input)) {
                        matches.push({ type: 'topic', value: topic, display: topic, concept: concept });
                    }
                }
                for (const term of related.terms || []) {
                    if (term.toLowerCase().includes(input)) {
                        matches.push({ type: 'term', value: term, display: term, concept: concept });
                    }
                }
            }

            // Sort: concepts first, then topics/terms grouped by concept
            matches.sort((a, b) => {
                if (a.type === 'concept' && b.type !== 'concept') return -1;
                if (a.type !== 'concept' && b.type === 'concept') return 1;
                if (a.type === 'concept') return a.value.localeCompare(b.value);
                if (a.concept === b.concept) return a.value.localeCompare(b.value);
                return a.concept.localeCompare(b.concept);
            });

            // Build dropdown HTML
            let html = '';
            let lastConcept = null;
            for (const match of matches.slice(0, 20)) { // Limit to 20 results
                // Clean display text - remove [[ and ]]
                const displayText = match.display.replace(/^\[\[/, '').replace(/\]\]$/, '');
                const conceptDisplay = match.concept ? match.concept.replace(/^\[\[/, '').replace(/\]\]$/, '') : '';
                
                if (match.type === 'concept') {
                    if (lastConcept !== null) html += '</div>';
                    html += `<div class="autocomplete-item concept-header" data-value="${match.value.replace(/"/g, '&quot;')}" data-type="concept">${displayText}</div>`;
                    lastConcept = match.value;
                } else {
                    if (lastConcept !== match.concept) {
                        if (lastConcept !== null) html += '</div>';
                        html += `<div class="autocomplete-item concept-header">${conceptDisplay}</div>`;
                        lastConcept = match.concept;
                    }
                    html += `<div class="autocomplete-item concept-related" data-value="${match.value.replace(/"/g, '&quot;')}" data-type="${match.type}">${displayText}</div>`;
                }
            }
            if (lastConcept !== null) html += '</div>';

            dropdown.innerHTML = html;
            
            // Position dropdown below input field
            // Find input's position relative to filter-section
            const filterSection = inputEl.closest('.filter-section');
            const label = filterSection.querySelector('.filter-label');
            const labelHeight = label ? label.offsetHeight + 6 : 0; // 6px is margin-bottom
            const inputTop = labelHeight;
            
            dropdown.style.position = 'absolute';
            dropdown.style.top = (inputTop + inputEl.offsetHeight + 2) + 'px';
            dropdown.style.left = '0px';
            dropdown.style.width = inputEl.offsetWidth + 'px';
            
            dropdown.classList.add('show');
            
            // Add event listeners to dropdown items
            dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = item.getAttribute('data-value');
                    const type = item.getAttribute('data-type');
                    
                    // Skip header items (they don't have data-value or have empty data-type)
                    if (value) {
                        selectConceptFilter(value, type || 'concept');
                    }
                });
            });
        }

        function handleDiscourseAutocomplete(event) {
            const input = event.target.value.toLowerCase();
            const dropdown = document.getElementById('discourseAutocomplete');
            const inputEl = event.target;
            
            if (!filterOptions || !input) {
                dropdown.classList.remove('show');
                return;
            }

            const matches = [];
            
            // Search both namespaces and specific elements
            // discourse_suggestions now contains tags (not full strings)
            for (const [namespace, tags] of Object.entries(filterOptions.discourse_suggestions)) {
                const nsLower = namespace.toLowerCase();
                const namespaceMatches = nsLower.includes(input);
                
                // Check if namespace matches
                if (namespaceMatches) {
                    matches.push({ type: 'namespace', value: namespace, display: namespace });
                }
                
                // Check specific tags within this namespace
                for (const tag of tags || []) {
                    // tag is already just the tag (e.g., "Logical/Claim"), not a full string
                    if (tag.toLowerCase().includes(input)) {
                        matches.push({ type: 'element', value: tag, display: tag, namespace: namespace });
                    }
                }
            }

            // Sort: namespaces first, then elements grouped by namespace
            matches.sort((a, b) => {
                if (a.type === 'namespace' && b.type !== 'namespace') return -1;
                if (a.type !== 'namespace' && b.type === 'namespace') return 1;
                if (a.type === 'namespace') return a.value.localeCompare(b.value);
                if (a.namespace === b.namespace) return a.value.localeCompare(b.value);
                return a.namespace.localeCompare(b.namespace);
            });

            let html = '';
            let lastNamespace = null;
            for (const match of matches.slice(0, 20)) {
                // Tags are already clean (no brackets), just use them as-is
                const displayText = match.display;
                const namespaceDisplay = match.namespace || '';
                
                if (match.type === 'namespace') {
                    if (lastNamespace !== null) html += '</div>';
                    html += `<div class="autocomplete-item concept-header" data-value="${match.value.replace(/"/g, '&quot;')}" data-filter-type="discourse">${displayText}</div>`;
                    lastNamespace = match.value;
                } else {
                    if (lastNamespace !== match.namespace) {
                        if (lastNamespace !== null) html += '</div>';
                        html += `<div class="autocomplete-item concept-header">${namespaceDisplay}</div>`;
                        lastNamespace = match.namespace;
                    }
                    html += `<div class="autocomplete-item concept-related" data-value="${match.value.replace(/"/g, '&quot;')}" data-filter-type="discourse">${displayText}</div>`;
                }
            }
            if (lastNamespace !== null) html += '</div>';

            dropdown.innerHTML = html;
            
            // Position dropdown below input field
            dropdown.style.position = 'absolute';
            dropdown.style.top = inputEl.offsetHeight + 2 + 'px';
            dropdown.style.left = '0px';
            dropdown.style.width = inputEl.offsetWidth + 'px';
            
            dropdown.classList.add('show');
            
            // Add event listeners to dropdown items
            dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = item.getAttribute('data-value');
                    const filterType = item.getAttribute('data-filter-type');
                    
                    if (filterType === 'discourse') {
                        selectDiscourseFilter(value);
                    }
                });
            });
        }

        function handleScriptureAutocomplete(event) {
            const input = event.target.value.toLowerCase();
            const dropdown = document.getElementById('scriptureAutocomplete');
            const inputEl = event.target;
            
            if (!filterOptions || !input) {
                dropdown.classList.remove('show');
                return;
            }

            const matches = filterOptions.scripture_references
                .filter(ref => ref.toLowerCase().includes(input))
                .slice(0, 20);

            dropdown.innerHTML = matches.map(ref => {
                const displayText = ref.replace(/^\[\[/, '').replace(/\]\]$/, '');
                return `<div class="autocomplete-item" data-value="${ref.replace(/"/g, '&quot;')}" data-filter-type="scripture">${displayText}</div>`;
            }).join('');
            
            // Position dropdown below input field
            dropdown.style.position = 'absolute';
            dropdown.style.top = inputEl.offsetHeight + 2 + 'px';
            dropdown.style.left = '0px';
            dropdown.style.width = inputEl.offsetWidth + 'px';
            
            dropdown.classList.add('show');
            
            // Add event listeners to dropdown items
            dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = item.getAttribute('data-value');
                    selectScriptureFilter(value);
                });
            });
        }

        function handleEntityAutocomplete(event) {
            const input = event.target.value.toLowerCase();
            const dropdown = document.getElementById('entityAutocomplete');
            const inputEl = event.target;
            
            if (!filterOptions || !input) {
                dropdown.classList.remove('show');
                return;
            }

            const matches = filterOptions.named_entities
                .filter(entity => entity.toLowerCase().includes(input))
                .slice(0, 20);

            dropdown.innerHTML = matches.map(entity => {
                const displayText = entity.replace(/^\[\[/, '').replace(/\]\]$/, '');
                return `<div class="autocomplete-item" data-value="${entity.replace(/"/g, '&quot;')}" data-filter-type="entity">${displayText}</div>`;
            }).join('');
            
            // Position dropdown below input field
            dropdown.style.position = 'absolute';
            dropdown.style.top = inputEl.offsetHeight + 2 + 'px';
            dropdown.style.left = '0px';
            dropdown.style.width = inputEl.offsetWidth + 'px';
            
            dropdown.classList.add('show');
            
            // Add event listeners to dropdown items
            dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = item.getAttribute('data-value');
                    const type = item.getAttribute('data-type');
                    const filterType = item.getAttribute('data-filter-type');
                    
                    if (filterType === 'discourse') {
                        selectDiscourseFilter(value);
                    } else if (filterType === 'scripture') {
                        selectScriptureFilter(value);
                    } else if (filterType === 'entity') {
                        selectEntityFilter(value);
                    } else {
                        // Concept/Topic/Term
                        selectConceptFilter(value, type);
                    }
                });
            });
        }

        function selectConceptFilter(value, type) {
            if (type === 'topic') {
                if (!selectedFilters.topics.includes(value)) {
                    selectedFilters.topics.push(value);
                }
            } else if (type === 'term') {
                if (!selectedFilters.terms.includes(value)) {
                    selectedFilters.terms.push(value);
                }
            } else {
                // Concept
                if (!selectedFilters.concepts.includes(value)) {
                    selectedFilters.concepts.push(value);
                }
            }
            updateSelectedFilters();
            document.getElementById('conceptFilterInput').value = '';
            document.getElementById('conceptAutocomplete').classList.remove('show');
        }

        function selectDiscourseFilter(value) {
            if (!selectedFilters.discourse_elements.includes(value)) {
                selectedFilters.discourse_elements.push(value);
            }
            updateSelectedFilters();
            document.getElementById('discourseFilterInput').value = '';
            document.getElementById('discourseAutocomplete').classList.remove('show');
        }

        function selectScriptureFilter(value) {
            if (!selectedFilters.scripture_references.includes(value)) {
                selectedFilters.scripture_references.push(value);
            }
            updateSelectedFilters();
            document.getElementById('scriptureFilterInput').value = '';
            document.getElementById('scriptureAutocomplete').classList.remove('show');
        }

        function selectEntityFilter(value) {
            if (!selectedFilters.named_entities.includes(value)) {
                selectedFilters.named_entities.push(value);
            }
            updateSelectedFilters();
            document.getElementById('entityFilterInput').value = '';
            document.getElementById('entityAutocomplete').classList.remove('show');
        }

        function updateSelectedFilters() {
            // Update concept/topic/term tags
            const container = document.getElementById('selectedConcepts');
            let html = '';
            selectedFilters.concepts.forEach(concept => {
                html += `<span class="filter-tag">${concept} <span class="remove-btn" onclick="removeConceptFilter('concept', '${concept.replace(/'/g, "\\'")}')">×</span></span>`;
            });
            selectedFilters.topics.forEach(topic => {
                html += `<span class="filter-tag">${topic} <span class="remove-btn" onclick="removeConceptFilter('topic', '${topic.replace(/'/g, "\\'")}')">×</span></span>`;
            });
            selectedFilters.terms.forEach(term => {
                html += `<span class="filter-tag">${term} <span class="remove-btn" onclick="removeConceptFilter('term', '${term.replace(/'/g, "\\'")}')">×</span></span>`;
            });
            container.innerHTML = html;

            // Update discourse tags
            const discourseContainer = document.getElementById('selectedDiscourse');
            html = '';
            selectedFilters.discourse_elements.forEach(de => {
                html += `<span class="filter-tag">${de} <span class="remove-btn" onclick="removeFilter('discourse_elements', '${de.replace(/'/g, "\\'")}')">×</span></span>`;
            });
            discourseContainer.innerHTML = html;

            // Update scripture tags
            const scriptureContainer = document.getElementById('selectedScripture');
            html = '';
            selectedFilters.scripture_references.forEach(ref => {
                html += `<span class="filter-tag">${ref} <span class="remove-btn" onclick="removeFilter('scripture_references', '${ref.replace(/'/g, "\\'")}')">×</span></span>`;
            });
            scriptureContainer.innerHTML = html;

            // Update entity tags
            const entityContainer = document.getElementById('selectedEntities');
            html = '';
            selectedFilters.named_entities.forEach(entity => {
                html += `<span class="filter-tag">${entity} <span class="remove-btn" onclick="removeFilter('named_entities', '${entity.replace(/'/g, "\\'")}')">×</span></span>`;
            });
            entityContainer.innerHTML = html;
        }

        function removeConceptFilter(type, value) {
            if (type === 'concept') {
                selectedFilters.concepts = selectedFilters.concepts.filter(c => c !== value);
            } else if (type === 'topic') {
                selectedFilters.topics = selectedFilters.topics.filter(t => t !== value);
            } else if (type === 'term') {
                selectedFilters.terms = selectedFilters.terms.filter(t => t !== value);
            }
            updateSelectedFilters();
        }

        function removeFilter(type, value) {
            if (selectedFilters[type]) {
                selectedFilters[type] = selectedFilters[type].filter(v => v !== value);
                updateSelectedFilters();
            }
        }

        function handleAutocompleteKeydown(event, type) {
            if (event.key === 'Escape') {
                const dropdowns = ['conceptAutocomplete', 'discourseAutocomplete', 'scriptureAutocomplete', 'entityAutocomplete'];
                dropdowns.forEach(id => document.getElementById(id).classList.remove('show'));
            }
        }

        async function applyFilters() {
            const sourcesContent = document.getElementById('sourcesContent');
            if (!sourcesContent) return;
            
            // Show loading state
            sourcesContent.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; padding: 20px;"><div class="spinner"></div><span style="margin-left: 10px;">Filtering results...</span></div>';

            try {
                // If we have current search results, filter them client-side
                if (currentSearchResult && currentSearchResult.chunks && currentSearchResult.chunks.length > 0) {
                    const filteredChunks = filterChunksClientSide(currentSearchResult.chunks, selectedFilters);
                    
                    // Format filtered results for display
                    const filteredSources = [];
                    filteredChunks.forEach((chunk, index) => {
                        const chunkObj = typeof chunk === 'object' && chunk !== null ? chunk : {};
                        const metadata = chunkObj.metadata || {};
                        const sourceEntry = {
                            number: index + 1,
                            source: chunkObj.source || 'Unknown Source',
                            author: chunkObj.author || 'Unknown Author',
                            location: metadata.structure_path || 'Unknown',
                            chunk_id: chunkObj.id || '',
                            _chunk_index: chunkObj._chunk_index !== undefined ? chunkObj._chunk_index : index,
                            metadata: metadata,
                            text: chunkObj.text || '',
                            similarity_score: chunkObj.similarity_score || 0,
                            final_score: chunkObj.final_score || 0
                        };
                        filteredSources.push(sourceEntry);
                    });
                    
                    // Update current search result with filtered data
                    const filteredResult = {
                        ...currentSearchResult,
                        sources_used: filteredSources,
                        chunks: filteredChunks
                    };
                    
                    // Display filtered results
                    displaySearchResults(filteredResult);
                } else {
                    // No current search results - filter entire dataset via backend
                    const response = await fetch('/api/filter-chunks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filters: selectedFilters })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        // Format data for display
                        const formattedResult = {
                            sources_used: data.sources_used,
                            chunks: data.sources_used.map(s => ({
                                text: s.text,
                                metadata: s.metadata,
                                source: s.source,
                                author: s.author,
                                id: s.chunk_id,
                                _chunk_index: s._chunk_index
                            })),
                            query: 'Filtered Results',
                            query_analysis: {},
                            reasoning_transparency: `Filtered ${data.total_count} chunks`
                        };
                        displaySearchResults(formattedResult);
                    } else {
                        sourcesContent.innerHTML = '<div class="error">Error applying filters</div>';
                    }
                }
            } catch (error) {
                console.error('Error applying filters:', error);
                sourcesContent.innerHTML = '<div class="error">Error applying filters: ' + error.message + '</div>';
            }
        }

        function filterChunksClientSide(chunks, filters) {
            if (!chunks || chunks.length === 0) return [];
            
            // Convert chunks to array if needed (they might be objects)
            const chunksArray = Array.isArray(chunks) ? chunks : Object.values(chunks);
            
            return chunksArray.filter(chunk => {
                const chunkObj = typeof chunk === 'object' && chunk !== null ? chunk : {};
                const metadata = chunkObj.metadata || {};
                
                // Source filter
                if (filters.sources && filters.sources.length > 0) {
                    if (!filters.sources.includes(chunkObj.source)) {
                        return false;
                    }
                }
                
                // Author filter
                if (filters.authors && filters.authors.length > 0) {
                    if (!filters.authors.includes(chunkObj.author)) {
                        return false;
                    }
                }
                
                // Concept/Topic/Term filters
                const chunkConcepts = new Set(metadata.concepts || []);
                const chunkTopics = new Set(metadata.topics || []);
                const chunkTerms = new Set(metadata.terms || []);
                
                // Extract concept namespaces from topics and terms
                chunkTopics.forEach(topic => {
                    const clean = topic.replace(/[\[\]]/g, '');
                    if (clean.includes('/')) {
                        chunkConcepts.add(clean.split('/')[0]);
                    }
                });
                chunkTerms.forEach(term => {
                    const clean = term.replace(/[\[\]]/g, '');
                    if (clean.includes('/')) {
                        chunkConcepts.add(clean.split('/')[0]);
                    }
                });
                
                if (filters.concepts && filters.concepts.length > 0) {
                    const filterConcepts = new Set(filters.concepts.map(c => c.replace(/[\[\]]/g, '')));
                    const chunkConceptsNormalized = new Set([...chunkConcepts].map(c => c.replace(/[\[\]]/g, '')));
                    if (![...filterConcepts].some(fc => [...chunkConceptsNormalized].some(cc => cc === fc || cc.startsWith(fc + '/')))) {
                        return false;
                    }
                }
                
                if (filters.topics && filters.topics.length > 0) {
                    const filterTopics = new Set(filters.topics.map(t => t.replace(/[\[\]]/g, '')));
                    const chunkTopicsNormalized = new Set([...chunkTopics].map(t => t.replace(/[\[\]]/g, '')));
                    if (![...filterTopics].some(ft => [...chunkTopicsNormalized].some(ct => ct === ft))) {
                        return false;
                    }
                }
                
                if (filters.terms && filters.terms.length > 0) {
                    const filterTerms = new Set(filters.terms.map(t => t.replace(/[\[\]]/g, '')));
                    const chunkTermsNormalized = new Set([...chunkTerms].map(t => t.replace(/[\[\]]/g, '')));
                    if (![...filterTerms].some(ft => [...chunkTermsNormalized].some(ct => ct === ft))) {
                        return false;
                    }
                }
                
                // Discourse elements filter
                const chunkDiscourseTags = new Set(metadata.discourse_tags || []);
                if (!chunkDiscourseTags.size && metadata.discourse_elements) {
                    metadata.discourse_elements.forEach(de => {
                        const match = de.match(/\[\[([^\]]+)\]\]/);
                        if (match) chunkDiscourseTags.add(match[1]);
                    });
                }
                
                if (filters.discourse_elements && filters.discourse_elements.length > 0) {
                    const filterDiscourse = new Set(filters.discourse_elements);
                    if (![...filterDiscourse].some(fd => {
                        if (fd.includes('/')) {
                            return chunkDiscourseTags.has(fd);
                        } else {
                            return [...chunkDiscourseTags].some(cd => cd === fd || cd.startsWith(fd + '/'));
                        }
                    })) {
                        return false;
                    }
                }
                
                // Scripture references filter
                if (filters.scripture_references && filters.scripture_references.length > 0) {
                    const chunkScripture = new Set(metadata.scripture_references || []);
                    if (![...chunkScripture].some(cs => filters.scripture_references.includes(cs))) {
                        return false;
                    }
                }
                
                // Named entities filter
                if (filters.named_entities && filters.named_entities.length > 0) {
                    const chunkEntities = new Set(metadata.named_entities || []);
                    if (![...chunkEntities].some(ce => filters.named_entities.includes(ce))) {
                        return false;
                    }
                }
                
                return true;
            });
        }

        function clearFilters() {
            selectedFilters = {
                sources: [],
                authors: [],
                concepts: [],
                topics: [],
                terms: [],
                discourse_elements: [],
                scripture_references: [],
                named_entities: []
            };
            
            // Clear UI
            updateSelectedFilters();
            
            // If we have current search results, restore them without filters
            if (currentSearchResult && currentSearchResult.chunks) {
                displaySearchResults(currentSearchResult);
            } else {
                const sourcesContent = document.getElementById('sourcesContent');
                if (sourcesContent) {
                    sourcesContent.innerHTML = '<div class="no-results">No filters applied</div>';
                }
            }
            
            // Clear checkboxes
            document.querySelectorAll('#sourceFilters input[type="checkbox"]').forEach(cb => cb.checked = false);
            document.querySelectorAll('#authorFilters input[type="checkbox"]').forEach(cb => cb.checked = false);
            
            // Clear autocomplete inputs
            document.getElementById('conceptFilterInput').value = '';
            document.getElementById('discourseFilterInput').value = '';
            document.getElementById('scriptureFilterInput').value = '';
            document.getElementById('entityFilterInput').value = '';
            
            // Clear dropdowns
            ['conceptAutocomplete', 'discourseAutocomplete', 'scriptureAutocomplete', 'entityAutocomplete'].forEach(id => {
                document.getElementById(id).classList.remove('show');
            });
            
            // Clear selected tags
            updateSelectedFilters();
            
            // Clear results
            const draftSources = document.getElementById('draftSourcesContent');
            if (!draftSources) return; // Draft layout removed
            draftSources.innerHTML = '<div class="no-results">No filters applied</div>';
        }

        // Close autocomplete dropdowns when clicking outside
        document.addEventListener('click', (event) => {
            // Don't close if clicking inside autocomplete dropdown
            if (event.target.closest('.autocomplete-dropdown')) {
                return;
            }
            // Close all dropdowns if clicking outside filter sections
            if (!event.target.closest('.filter-section')) {
                ['conceptAutocomplete', 'discourseAutocomplete', 'scriptureAutocomplete', 'entityAutocomplete'].forEach(id => {
                    document.getElementById(id).classList.remove('show');
                });
            }
        });

        function copyToClipboard(event) {
            const btn = event.target;
            const textToCopy = decodeURIComponent(btn.getAttribute('data-text') || '');
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Show brief feedback
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = '#d4edda';
                btn.style.color = '#155724';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#f0f0f0';
                    btn.style.color = '#666';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        function performSearch() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query) {
                alert('Please enter a research question');
                return;
            }

            if (selectedSources.size === 0) {
                alert('Please select at least one source');
                return;
            }

            const searchBtn = document.getElementById('searchBtn');
            const loading = document.getElementById('loading');
            const generateSummaryBtn = document.getElementById('generateSummaryBtn');

            // Show loading state
            searchBtn.disabled = true;
            loading.style.display = 'block';
            
            // Keep layout visible but show loading in panels
            document.getElementById('layoutContainer').style.display = 'flex';
            
            // Show loading in Research Summary panel
            document.getElementById('researchContent').innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; min-height: 200px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Analyzing query and searching sources...</span>
                </div>
            `;
            
            // Show loading in Sources & Citations panel
            document.getElementById('sourcesContent').innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; padding: 40px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Searching...</span>
                </div>
            `;

            // Prepare request data
            const requestData = {
                query: query,
                sources: Array.from(selectedSources)
            };

            // Make API request to search-only endpoint
            fetch('/api/search-only', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                currentSearchResult = data;
                currentSearchId = null; // Reset - this is a new search, not from history
                displaySearchResults(data);
                document.getElementById('saveSearchBtn').disabled = false;
                
                // Enable the generate summary button
                const btn = document.getElementById('generateSummaryBtn');
                if (btn) btn.disabled = false;
            })
            .catch(error => {
                console.error('Search error:', error);
                document.getElementById('sourcesContent').innerHTML = `
                    <div class="error">Error: ${error.message}</div>
                `;
            })
            .finally(() => {
                searchBtn.disabled = false;
                loading.style.display = 'none';
                // Layout is already visible, no need to show it again
            });
        }

        function generateSummary() {
            if (!currentSearchResult || !currentSearchResult.chunks || currentSearchResult.chunks.length === 0) {
                alert('Please perform a search first');
                return;
            }

            const generateSummaryBtn = document.getElementById('generateSummaryBtn');
            const researchContent = document.getElementById('researchContent');

            // Show loading state
            generateSummaryBtn.disabled = true;
            researchContent.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; min-height: 200px;">
                    <div class="spinner"></div>
                    <span style="margin-left: 10px;">Generating AI summary...</span>
                </div>
            `;

            // Prepare request data
            const requestData = {
                query: currentSearchResult.query || document.getElementById('queryInput').value.trim(),
                chunks: currentSearchResult.chunks,
                query_analysis: currentSearchResult.query_analysis || {},
                reasoning_transparency: currentSearchResult.reasoning_transparency || null  // Preserve original search strategy
            };

            // Make streaming API request to generate summary
            requestData.stream = true; // Enable streaming
            
            // Set up display area for streaming content
            let reasoningHtml = '';
            if (currentSearchResult.reasoning_transparency) {
                reasoningHtml = `
                    <div class="reasoning-section">
                        <div class="reasoning-title">Search Strategy</div>
                        <div class="reasoning-text">${currentSearchResult.reasoning_transparency}</div>
                    </div>
                `;
            }
            
            researchContent.innerHTML = reasoningHtml + `
                <div class="summary" id="streamingSummary"></div>
            `;
            
            const summaryElement = document.getElementById('streamingSummary');
            let accumulatedSummary = '';
            
            // Use EventSource for Server-Sent Events
            fetch('/api/generate-summary', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                function processStream() {
                    return reader.read().then(({ done, value }) => {
                        if (done) {
                            // Stream ended - check if we have any remaining buffer
                            if (buffer.trim()) {
                                const lines = buffer.split('\n');
                                for (const line of lines) {
                                    if (line.startsWith('data: ')) {
                                        try {
                                            const data = JSON.parse(line.slice(6));
                                            if (data.type === 'complete') {
                                                // Handle completion
                                                currentSearchResult.summary = data.summary;
                                                currentSearchResult.sources_used = data.sources_used;
                                                currentSearchResult.reasoning_transparency = data.reasoning_transparency;
                                                displaySummary(data);
                                                generateSummaryBtn.disabled = false;
                                            }
                                        } catch (e) {
                                            console.error('Error parsing final data:', e);
                                        }
                                    }
                                }
                            }
                            return;
                        }
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // Keep incomplete line in buffer
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    
                                    if (data.type === 'start') {
                                        // Stream started
                                        accumulatedSummary = '';
                                        summaryElement.innerHTML = '';
                                    } else if (data.type === 'chunk') {
                                        // Append chunk to summary
                                        accumulatedSummary += data.content;
                                        // Parse markdown and update display
                                        const parsedMarkdown = parseMarkdown(accumulatedSummary);
                                        summaryElement.innerHTML = parsedMarkdown;
                                        // Auto-scroll to bottom
                                        summaryElement.scrollTop = summaryElement.scrollHeight;
                                    } else if (data.type === 'complete') {
                                        // Stream complete, finalize
                                        currentSearchResult.summary = data.summary;
                                        currentSearchResult.sources_used = data.sources_used;
                                        currentSearchResult.reasoning_transparency = data.reasoning_transparency;
                                        
                                        // Update saved search history entry if it exists
                                        if (currentSearchId) {
                                            const savedEntryIndex = searchHistory.findIndex(entry => entry.id === currentSearchId);
                                            if (savedEntryIndex !== -1) {
                                                searchHistory[savedEntryIndex].summary = data.summary;
                                                searchHistory[savedEntryIndex].reasoning = data.reasoning_transparency;
                                                searchHistory[savedEntryIndex].sources = data.sources_used;
                                                if (currentSearchResult.query_analysis) {
                                                    searchHistory[savedEntryIndex].query_analysis = currentSearchResult.query_analysis;
                                                }
                                                localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                                                autoBackupSearchHistory();
                                            }
                                        }
                                        
                                        // Final display with all data
                                        displaySummary(data);
                                        generateSummaryBtn.disabled = false;
                                        return;
                                    } else if (data.type === 'error') {
                                        throw new Error(data.message || 'Unknown error');
                                    }
                                } catch (e) {
                                    console.error('Error parsing stream data:', e);
                                }
                            }
                        }
                        
                        return processStream();
                    });
                }
                
                return processStream();
            })
            .catch(error => {
                console.error('Summary generation error:', error);
                researchContent.innerHTML = `
                    <div class="error">Error generating summary: ${error.message}</div>
                    <div style="margin-top: 12px; text-align: center;">
                        <button class="search-btn" id="generateSummaryBtn" onclick="generateSummary()" style="padding: 12px 24px; font-size: 14px;">Try Again</button>
                    </div>
                `;
                generateSummaryBtn.disabled = false;
            });
        }

        function displaySummary(data) {
            const researchContent = document.getElementById('researchContent');
            
            // Display reasoning section
            let reasoningHtml = '';
            if (data.reasoning_transparency) {
                reasoningHtml = `
                    <div class="reasoning-section">
                        <div class="reasoning-title">Search Strategy</div>
                        <div class="reasoning-text">${data.reasoning_transparency}</div>
                    </div>
                `;
            }

            // Parse markdown (citations are already handled in parseMarkdown)
            const parsedMarkdown = parseMarkdown(data.summary);
            researchContent.innerHTML = reasoningHtml + `
                <div class="summary">${parsedMarkdown}</div>
            `;
        }

        function displaySearchResults(data) {
            const sourcesContent = document.getElementById('sourcesContent');
            const researchContent = document.getElementById('researchContent');

            // Store sources for citation handling
            currentSources = data.sources_used || [];

            // Display search strategy immediately (even if no summary yet)
            let reasoningHtml = '';
            if (data.reasoning_transparency) {
                reasoningHtml = `
                    <div class="reasoning-section">
                        <div class="reasoning-title">Search Strategy</div>
                        <div class="reasoning-text">${data.reasoning_transparency}</div>
                    </div>
                `;
            }

            // If there's a summary, display it; otherwise show the button
            if (data.summary) {
                // Parse markdown (citations are already handled in parseMarkdown)
                const parsedMarkdown = parseMarkdown(data.summary);
                researchContent.innerHTML = reasoningHtml + `
                    <div class="summary">${parsedMarkdown}</div>
                `;
            } else {
                // Show search strategy and button
                researchContent.innerHTML = reasoningHtml + `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; min-height: 200px; margin-top: 20px;">
                        <button class="search-btn" id="generateSummaryBtn" onclick="generateSummary()" style="padding: 12px 24px; font-size: 14px;">Get AI Summary</button>
                    </div>
                `;
            }

            // Display sources (search-only results don't have summary yet)
            let sourcesHtml = '';
            if (currentSources.length > 0) {
                sourcesHtml = currentSources.map((source, index) => {
                    const sourceNumber = source.number || (index + 1);
                    const chunkText = source.text || findSourceText(sourceNumber, data.chunks);
                    
                    // Build metadata tooltip
                    const metadata = source.metadata || {};
                    let tooltipContent = '';
                    
                    if (metadata.topics && metadata.topics.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Topics</div><div class="metadata-values">${metadata.topics.join(', ')}</div></div>`;
                    }
                    if (metadata.concepts && metadata.concepts.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Concepts</div><div class="metadata-values">${metadata.concepts.join(', ')}</div></div>`;
                    }
                    if (metadata.terms && metadata.terms.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Terms</div><div class="metadata-values">${metadata.terms.join(', ')}</div></div>`;
                    }
                    if (metadata.discourse_elements && metadata.discourse_elements.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Discourse Elements</div><div class="metadata-values">${metadata.discourse_elements.join(', ')}</div></div>`;
                    }
                    if (metadata.scripture_references && metadata.scripture_references.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Scripture References</div><div class="metadata-values">${metadata.scripture_references.join(', ')}</div></div>`;
                    }
                    if (metadata.named_entities && metadata.named_entities.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Named Entities</div><div class="metadata-values">${metadata.named_entities.join(', ')}</div></div>`;
                    }
                    if (metadata.structure_path) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Location</div><div class="metadata-values">${metadata.structure_path}</div></div>`;
                    }

                    return `
                        <div class="source-item" id="source-${sourceNumber}">
                            <div class="source-header">
                                <div class="source-number">${sourceNumber}</div>
                                <div class="source-title">${source.source || 'Unknown Source'}</div>
                                ${tooltipContent ? `
                                <div class="metadata-tooltip">
                                    <span style="cursor: help; color: #666;">ⓘ</span>
                                    <div class="tooltip-content">${tooltipContent}</div>
                                </div>
                                ` : ''}
                            </div>
                            <div class="source-meta">
                                ${source.author ? `Author: ${source.author}` : ''}
                                ${source.location && source.location !== 'Unknown' ? ` • Location: ${source.location.replace(/^\[\[/, '').replace(/\]\]$/, '')}` : ''}
                            </div>
                            <div class="source-text">${chunkText}</div>
                            ${source.relevance_explanation ? `
                                <div class="source-relevance">
                                    <strong>Why this source:</strong> ${source.relevance_explanation}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            } else {
                sourcesHtml = '<div class="no-results">No sources found</div>';
            }

            sourcesContent.innerHTML = sourcesHtml;
            
            // Show research layout
            document.getElementById('layoutContainer').style.display = 'flex';
            document.getElementById('researchLayout').style.display = 'grid';
            
            // Ensure normal grid layout when displaying results
            const researchLayout = document.getElementById('researchLayout');
            researchLayout.style.gridTemplateColumns = '2fr 1fr 200px';
            const researchPanel = researchLayout.children[0];
            const sourcesPanel = researchLayout.children[1];
            researchPanel.style.display = 'block';
            sourcesPanel.style.display = 'block';
        }

        function parseMarkdown(text) {
            if (!text) return '';
            
            let html = text;
            
            // First, protect citations from being processed (both [1] and (1) formats)
            // Use a unique placeholder pattern that won't conflict with markdown syntax
            const citationPlaceholders = [];
            // Handle parentheses citations (1)
            html = html.replace(/\((\d+)\)/g, (match, num) => {
                const placeholder = `{{CITATION_${citationPlaceholders.length}}}`;
                citationPlaceholders.push(match);
                return placeholder;
            });
            // Handle square bracket citations [1]
            html = html.replace(/\[(\d+)\]/g, (match, num) => {
                const placeholder = `{{CITATION_${citationPlaceholders.length}}}`;
                citationPlaceholders.push(match);
                return placeholder;
            });
            
            // Convert bold first (**text** or __text__) - but not in list contexts
            // We'll do this after lists to avoid interfering
            
            // Convert headers (###, ##, #) - but skip if inside a list context
            // Process h3 first, then h2, then h1
            // Headers on their own lines won't interfere with lists
            
            // Convert numbered lists (1. item)
            // First, find all lines that start with number patterns
            const lines = html.split('\n');
            let inNumberedList = false;
            let numberedListItems = [];
            let processedLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const numberedMatch = line.match(/^(\d+)\.\s+(.+)$/);
                
                if (numberedMatch) {
                    if (!inNumberedList) {
                        // Start new list
                        inNumberedList = true;
                        numberedListItems = [];
                    }
                    numberedListItems.push(numberedMatch[2]);
                } else {
                    // Check if this is a continuation of previous list item
                    if (inNumberedList && line.trim() && !line.match(/^(<|#|-|\*|\d+\.)/)) {
                        // Append to last list item
                        if (numberedListItems.length > 0) {
                            numberedListItems[numberedListItems.length - 1] += ' ' + line.trim();
                        }
                    } else {
                        // End current list if any
                        if (inNumberedList) {
                            const listHtml = '<ol>' + numberedListItems.map(item => `<li>${item}</li>`).join('') + '</ol>';
                            processedLines.push(listHtml);
                            numberedListItems = [];
                            inNumberedList = false;
                        }
                        processedLines.push(line);
                    }
                }
            }
            
            // Close any open list at the end
            if (inNumberedList && numberedListItems.length > 0) {
                const listHtml = '<ol>' + numberedListItems.map(item => `<li>${item}</li>`).join('') + '</ol>';
                processedLines.push(listHtml);
            }
            
            html = processedLines.join('\n');
            
            // Convert bullet lists (- item or * item) - similar approach
            const bulletLines = html.split('\n');
            let inBulletList = false;
            let bulletListItems = [];
            let processedBulletLines = [];
            
            for (let i = 0; i < bulletLines.length; i++) {
                const line = bulletLines[i];
                const bulletMatch = line.match(/^[-*]\s+(.+)$/);
                
                if (bulletMatch) {
                    if (!inBulletList) {
                        inBulletList = true;
                        bulletListItems = [];
                    }
                    bulletListItems.push(bulletMatch[1]);
                } else {
                    if (inBulletList && line.trim() && !line.match(/^(<|#|-|\*|\d+\.)/)) {
                        if (bulletListItems.length > 0) {
                            bulletListItems[bulletListItems.length - 1] += ' ' + line.trim();
                        }
                    } else {
                        if (inBulletList) {
                            const listHtml = '<ul>' + bulletListItems.map(item => `<li>${item}</li>`).join('') + '</ul>';
                            processedBulletLines.push(listHtml);
                            bulletListItems = [];
                            inBulletList = false;
                        }
                        processedBulletLines.push(line);
                    }
                }
            }
            
            if (inBulletList && bulletListItems.length > 0) {
                const listHtml = '<ul>' + bulletListItems.map(item => `<li>${item}</li>`).join('') + '</ul>';
                processedBulletLines.push(listHtml);
            }
            
            html = processedBulletLines.join('\n');
            
            // Now convert headers (###, ##, #) - but skip headers that are part of numbered lists
            // Handle numbered list items that start with headers like "#### 6. Text" first
            html = html.replace(/^####\s+(\d+)\.\s+(.+)$/gm, '<li><strong>$2</strong></li>');
            html = html.replace(/^###\s+(\d+)\.\s+(.+)$/gm, '<li><strong>$2</strong></li>');
            html = html.replace(/^##\s+(\d+)\.\s+(.+)$/gm, '<li><strong>$2</strong></li>');
            html = html.replace(/^#\s+(\d+)\.\s+(.+)$/gm, '<li><strong>$2</strong></li>');
            
            // Now convert regular headers (that don't start with numbers)
            html = html.replace(/^####\s+(?!\d+\.\s)(.+)$/gm, '<h4>$1</h4>');
            html = html.replace(/^###\s+(?!\d+\.\s)(.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^##\s+(?!\d+\.\s)(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#\s+(?!\d+\.\s)(.+)$/gm, '<h1>$1</h1>');
            
            // Convert bold (**text** or __text__) - can appear anywhere now
            // But make sure we don't match citation placeholders
            html = html.replace(/\*\*([^*\n]+)\*\*/g, '<strong>$1</strong>');
            // Only match __text__ if it's not part of a citation placeholder
            html = html.replace(/__([^_\n{]+)__/g, '<strong>$1</strong>');
            
            // Split into paragraphs (double newlines or single newline after block elements)
            // First, replace double newlines with paragraph markers
            html = html.replace(/\n\n+/g, '\n\nPARAGRAPH_BREAK\n\n');
            
            // Split and process
            const parts = html.split(/\n\nPARAGRAPH_BREAK\n\n/);
            html = parts.map(p => {
                p = p.trim();
                // Don't wrap if it's already a tag (heading, list) or starts with HTML
                if (p.match(/^<(h[1-6]|ol|ul|li|p)/)) {
                    return p;
                }
                // If it contains block-level HTML tags, don't wrap
                if (p.includes('<ol>') || p.includes('<ul>') || p.includes('<h')) {
                    return p;
                }
                if (p) {
                    return `<p>${p}</p>`;
                }
                return '';
            }).join('\n\n');
            
            // Restore citations from placeholders and make them clickable
            citationPlaceholders.forEach((citation, index) => {
                // Replace placeholder with clickable citation
                // Try to match both formats: parentheses (1) and square brackets [1]
                const citationNumParentheses = citation.match(/\((\d+)\)/);
                const citationNumBrackets = citation.match(/\[(\d+)\]/);
                const citationNum = citationNumParentheses || citationNumBrackets;
                if (citationNum) {
                    const num = citationNum[1];
                    // Escape curly braces in regex
                    const placeholderPattern = `\\{\\{CITATION_${index}\\}\\}`;
                    // Preserve original format (parentheses or brackets)
                    const formattedCitation = citationNumParentheses 
                        ? `(${num})` 
                        : `[${num}]`;
                    html = html.replace(new RegExp(placeholderPattern, 'g'), 
                        `<span class="citation" onclick="scrollToSource(${num})">${formattedCitation}</span>`);
                } else {
                    // Fallback: just restore the original citation
                    const placeholderPattern = `\\{\\{CITATION_${index}\\}\\}`;
                    html = html.replace(new RegExp(placeholderPattern, 'g'), citation);
                }
            });
            
            return html;
        }

        function addCitationClickHandlers(summary) {
            // This function is now mostly redundant since citations are handled in parseMarkdown
            // But keep it for any citations that weren't protected as placeholders
            // Handle both parentheses (1) and square brackets [1]
            summary = summary.replace(/\((\d+)\)/g, '<span class="citation" onclick="scrollToSource($1)">($1)</span>');
            summary = summary.replace(/\[(\d+)\]/g, '<span class="citation" onclick="scrollToSource($1)">[$1]</span>');
            return summary;
        }

        function scrollToSource(sourceNumber) {
            const sourceElement = document.getElementById(`source-${sourceNumber}`);
            if (sourceElement) {
                // Remove previous highlights
                document.querySelectorAll('.source-item').forEach(item => {
                    item.classList.remove('highlighted');
                });
                
                // Highlight and scroll to source
                sourceElement.classList.add('highlighted');
                sourceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    sourceElement.classList.remove('highlighted');
                }, 3000);
            }
        }

        function findSourceText(sourceNumber, chunks) {
            // Find the chunk text for this source number
            if (!chunks || chunks.length === 0) {
                return 'Text not available';
            }
            
            // Get the source info for this number
            const sourceInfo = currentSources[sourceNumber - 1];
            if (!sourceInfo) {
                return 'Text not available';
            }
            
            // Try to find chunk by matching _chunk_index value (not using it as array index)
            // This works for both fresh searches and loaded history
            if (sourceInfo._chunk_index !== undefined && sourceInfo._chunk_index >= 0) {
                const chunk = chunks.find(c => c._chunk_index === sourceInfo._chunk_index);
                if (chunk && chunk.text) {
                    return chunk.text;
                }
            }
            
            // Fallback 1: Match by chunk_id if available
            if (sourceInfo.chunk_id) {
                const chunk = chunks.find(c => c.id === sourceInfo.chunk_id);
                if (chunk && chunk.text) {
                    return chunk.text;
                }
            }
            
            // Fallback 2: If sources have the same order as chunks, try array index
            // This is a last resort for backwards compatibility
            if (sourceInfo._chunk_index !== undefined && 
                sourceInfo._chunk_index >= 0 && 
                sourceInfo._chunk_index < chunks.length) {
                const chunk = chunks[sourceInfo._chunk_index];
                if (chunk && chunk.text) {
                    return chunk.text;
                }
            }
            
            // Fallback 3: Return a placeholder
            return 'Source text unavailable';
        }
    </script>
</body>
</html>