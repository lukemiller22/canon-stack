<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CanonStack Scribe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #2d2d2d;
            line-height: 1.4;
            font-size: 14px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 12px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .layout-container {
            display: flex;
            flex: 1;
            gap: 8px;
            overflow: hidden;
            min-height: 0; /* allow children to shrink and scroll */
            height: 100%;
        }

        .layout-sidebar {
            width: 40px;
            background: #f8f8f8;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px;
            gap: 8px;
        }

        .layout-icon {
            width: 32px;
            height: 32px;
            border: 1px solid #c0c0c0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: white;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .layout-icon:hover {
            background: #e8f4fd;
            border-color: #4a90e2;
        }

        .layout-icon.active {
            background: #4a90e2;
            color: white;
            border-color: #4a90e2;
        }

        .main-layout {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* critical for nested scrolling */
            height: 100%;
        }

        .draft-panel {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .draft-header {
            background: #f8f8f8;
            border-bottom: 1px solid #d0d0d0;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .draft-title {
            font-weight: 600;
            font-size: 14px;
            color: #2d2d2d;
        }

        .draft-textarea {
            flex: 1;
            border: none;
            padding: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
            background: white;
        }

        .draft-textarea:focus {
            outline: none;
        }

        .copy-options {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .copy-btn {
            padding: 2px 6px;
            font-size: 10px;
            background: #f0f0f0;
            border: 1px solid #c0c0c0;
            border-radius: 2px;
            cursor: pointer;
            color: #666;
        }

        .copy-btn:hover {
            background: #e0e0e0;
            color: #333;
        }

        .header {
            background: #3a3a3a;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
        }

        .header p {
            font-size: 12px;
            color: #bbb;
        }

        .toolbar {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-section {
            display: flex;
            gap: 8px;
            flex: 1;
            align-items: center;
        }

        .search-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            font-size: 14px;
            min-width: 200px;
        }

        .search-input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 3px rgba(74, 144, 226, 0.3);
        }

        .search-btn {
            padding: 6px 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
        }

        .search-btn:hover:not(:disabled) {
            background: #357abd;
        }

        .search-btn:disabled {
            background: #999;
            cursor: not-allowed;
        }

        .source-selector {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .source-selector label {
            font-size: 12px;
            font-weight: 500;
            color: #555;
        }

        .source-dropdown {
            padding: 4px 8px;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            font-size: 13px;
            background: white;
            min-width: 150px;
        }

        .history-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .history-btn {
            padding: 4px 8px;
            background: #f8f8f8;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            color: #555;
        }

        .history-btn:hover {
            background: #e8e8e8;
        }

        .history-btn.active {
            background: #4a90e2;
            color: white;
            border-color: #4a90e2;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 12px;
            color: #666;
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            border-top-color: #4a90e2;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr 200px;
            gap: 8px;
            flex: 1 1 0;
            min-height: 0;
            align-items: stretch;
            height: 100%; /* ensure panels receive height */
        }

        .panel {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: 100%;
            max-height: 100%;
        }

        .panel-header {
            background: #f0f0f0;
            border-bottom: 1px solid #d0d0d0;
            padding: 6px 10px;
            font-size: 13px;
            font-weight: 600;
            color: #333;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .filter-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
        }

        .filter-btn:hover {
            background: #357abd;
        }

        .filter-tray {
            background: #f8f8f8;
            border-bottom: 1px solid #d0d0d0;
            padding: 12px;
            flex-shrink: 0;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: visible;
            position: relative;
        }

        .filter-section {
            margin-bottom: 16px;
            position: relative;
        }

        .filter-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 120px;
            overflow-y: auto;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .checkbox-item input[type="checkbox"] {
            cursor: pointer;
        }

        .checkbox-item label {
            cursor: pointer;
            flex: 1;
            color: #555;
        }

        .autocomplete-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            font-size: 12px;
            box-sizing: border-box;
        }

        .autocomplete-input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 3px rgba(74, 144, 226, 0.3);
        }

        .autocomplete-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #c0c0c0;
            border-radius: 3px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: none;
            margin-top: 2px;
            width: 100%;
            box-sizing: border-box;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .autocomplete-item:hover {
            background: #f0f0f0;
        }

        .autocomplete-item.concept-header {
            font-weight: 600;
            background: #e8f4f8;
            color: #2d5aa0;
        }

        .autocomplete-item.concept-related {
            padding-left: 24px;
            color: #666;
        }

        .selected-filters {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .filter-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #4a90e2;
            color: white;
            border-radius: 3px;
            font-size: 11px;
        }

        .filter-tag .remove-btn {
            cursor: pointer;
            font-weight: bold;
            opacity: 0.8;
        }

        .filter-tag .remove-btn:hover {
            opacity: 1;
        }

        .filter-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #d0d0d0;
        }

        .filter-actions .search-btn {
            flex: 1;
        }

        .panel-content {
            padding: 10px 10px 28px; /* extra bottom padding so last line isn't clipped */
            flex: 1 1 auto;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            max-height: 100%;
            box-sizing: border-box;
            scroll-padding-bottom: 28px; /* ensure scroll snaps allow viewing padded end */
            -webkit-overflow-scrolling: touch;
            position: relative;
            overscroll-behavior: contain;
        }

        .reasoning-section {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 12px;
        }

        .reasoning-title {
            font-weight: 600;
            color: #555;
            margin-bottom: 4px;
            font-size: 12px;
            text-transform: uppercase;
        }

        .reasoning-text {
            color: #666;
            font-size: 13px;
            line-height: 1.3;
        }

        .summary {
            font-size: 14px;
            line-height: 1.5;
            color: #2d2d2d;
        }

        .summary p {
            margin-bottom: 10px;
        }

        .summary h1, .summary h2, .summary h3, .summary h4 {
            margin-top: 16px;
            margin-bottom: 12px;
            font-weight: 600;
            color: #1a1a1a;
            line-height: 1.3;
        }

        .summary h1 {
            font-size: 22px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 8px;
            margin-top: 0;
        }

        .summary h2 {
            font-size: 20px;
            margin-top: 20px;
        }

        .summary h3 {
            font-size: 18px;
            margin-top: 16px;
        }

        .summary h4 {
            font-size: 16px;
            margin-top: 14px;
        }

        .summary strong, .summary b {
            font-weight: 600;
            color: #1a1a1a;
        }

        .summary ol, .summary ul {
            margin: 12px 0;
            padding-left: 24px;
        }

        .summary li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .summary ol {
            list-style-type: decimal;
        }

        .summary ul {
            list-style-type: disc;
        }

        .citation {
            background: #e6f3ff;
            color: #0066cc;
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .citation:hover {
            background: #cce7ff;
        }

        .source-item {
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 6px;
            transition: all 0.2s;
            font-size: 13px;
        }

        .source-item:hover {
            border-color: #4a90e2;
            box-shadow: 0 1px 3px rgba(74, 144, 226, 0.2);
        }

        .source-item.highlighted {
            border-color: #4a90e2;
            background: #f0f7ff;
            box-shadow: 0 2px 6px rgba(74, 144, 226, 0.3);
        }

        .source-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .source-number {
            background: #4a90e2;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
        }

        .source-title {
            font-weight: 600;
            color: #2d2d2d;
            font-size: 13px;
        }

        .source-meta {
            color: #666;
            font-size: 11px;
            margin-bottom: 6px;
        }

        .source-text {
            color: #555;
            line-height: 1.4;
            font-size: 12px;
        }

        .source-relevance {
            background: #f0f8ff;
            border-left: 2px solid #4a90e2;
            padding: 6px;
            margin-top: 6px;
            font-size: 11px;
            color: #2d5aa0;
        }

        .metadata-tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .metadata-tooltip .tooltip-content {
            visibility: hidden;
            width: 280px;
            background-color: #2d2d2d;
            color: #f0f0f0;
            text-align: left;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            top: 100%;
            right: 0;
            margin-top: 4px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 11px;
            line-height: 1.3;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .metadata-tooltip .tooltip-content::after {
            content: "";
            position: absolute;
            bottom: 100%;
            right: 15px;
            border-width: 4px;
            border-style: solid;
            border-color: transparent transparent #2d2d2d transparent;
        }

        .metadata-tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        .metadata-section {
            margin-bottom: 6px;
        }

        .metadata-label {
            font-weight: 600;
            color: #aaa;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metadata-values {
            color: #ddd;
            margin-top: 2px;
        }

        .history-panel {
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
        }

        .history-item {
            padding: 6px 8px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 12px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .history-item:hover {
            background: #f5f5f5;
        }

        .delete-draft-btn {
            background: transparent;
            border: none;
            color: #999;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .delete-draft-btn:hover {
            background: #ff6b6b;
            color: white;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-query {
            font-weight: 500;
            color: #2d2d2d;
            margin-bottom: 2px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .history-meta {
            color: #666;
            font-size: 11px;
        }

        .error {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            color: #c53030;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-size: 13px;
        }

        .no-results {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 13px;
        }

        .source-checkbox {
            margin-right: 6px;
            transform: scale(0.9);
        }

        .source-list-item {
            display: flex;
            align-items: center;
            padding: 4px 0;
            font-size: 12px;
        }

        .source-list-item label {
            cursor: pointer;
            display: flex;
            align-items: center;
            width: 100%;
        }

        .source-count {
            color: #666;
            font-size: 11px;
            margin-left: auto;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
            
            .history-panel {
                max-height: 200px;
            }
        }

        .search-history-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .clear-history-btn {
            padding: 4px 8px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 6px;
        }

        .clear-history-btn:hover {
            background: #ff5252;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>CanonStack Scribe</h1>
                <p>Your theological research stack</p>
            </div>
        </div>

        <div class="toolbar">
            <div class="search-section">
                <input 
                    type="text" 
                    class="search-input" 
                    id="queryInput" 
                    placeholder="Enter your theological question or research topic..."
                />
                <button class="search-btn" id="searchBtn" onclick="performSearch()">Research</button>
            </div>
            
            <div class="source-selector">
                <label>Sources:</label>
                <select class="source-dropdown" id="sourceStack">
                    <option value="all">All Sources</option>
                    <option value="custom">Custom Selection</option>
                </select>
            </div>
            
            <div class="history-controls">
                <button class="history-btn" id="saveSearchBtn" onclick="saveCurrentSearch()" disabled>Save</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <span style="margin-left: 8px;">Analyzing query and searching sources...</span>
        </div>

        <div class="layout-container" id="layoutContainer" style="display: flex;">
            <div class="layout-sidebar">
                <div class="layout-icon active" id="researchIcon" onclick="switchLayout('research')" title="Research Mode">
                    <svg width="18" height="18" viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="8" cy="8" r="6"></circle>
                        <path d="m14 14-3-3"></path>
                    </svg>
                </div>
                <div class="layout-icon" id="draftIcon" onclick="switchLayout('draft')" title="Draft Mode">
                    <svg width="18" height="18" viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 3H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2Z"></path>
                        <path d="M7 7h4M7 11h2M7 9h3"></path>
                    </svg>
                </div>
            </div>
            
            <div class="main-layout">
                <!-- Research Layout -->
                <div class="main-content" id="researchLayout" style="display: grid;">
                    <div class="panel">
                        <div class="panel-header">Research Summary</div>
                        <div class="panel-content" id="researchContent"></div>
                    </div>

                    <div class="panel">
                        <div class="panel-header">Sources & Citations</div>
                        <div class="panel-content" id="sourcesContent"></div>
                    </div>

                    <div class="panel history-panel">
                        <div class="panel-header">
                            Search History
                            <button class="clear-history-btn" onclick="clearSearchHistory()">Clear All</button>
                        </div>
                        <div class="panel-content">
                            <div id="sourceSelectionSection" style="display: none;">
                                <div style="font-weight: 600; margin-bottom: 8px; font-size: 12px;">Select Sources:</div>
                                <div id="sourcesList"></div>
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                    <button class="history-btn" onclick="selectAllSources()">All</button>
                                    <button class="history-btn" onclick="selectNoSources()">None</button>
                                    <button class="history-btn" onclick="applySourceSelection()">Apply</button>
                                </div>
                            </div>
                            <div id="searchHistorySection">
                                <div class="search-history-list" id="searchHistoryList">
                                    <div class="no-results">No saved searches yet</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Draft Layout -->
                <div class="main-content" id="draftLayout" style="display: none;">
                    <div class="draft-panel">
                        <div class="draft-header">
                            <div class="draft-title">Draft</div>
                            <div style="display: flex; gap: 8px;">
                                <button class="search-btn" id="newDraftBtn" onclick="newDraft()">New Draft</button>
                                <button class="search-btn" id="findCitationsBtn" onclick="findCitationsForDraft()">Find Citations</button>
                                <button class="search-btn" id="saveDraftBtn" onclick="saveDraft()">Save Draft</button>
                            </div>
                        </div>
                        <textarea class="draft-textarea" id="draftTextarea" placeholder="Start writing your theological draft here..."></textarea>
                    </div>

                    <div class="panel">
                        <div class="panel-header">
                            Sources & Citations
                            <button class="filter-btn" id="filterBtn" onclick="toggleFilterTray()" title="Toggle Filters">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M2 4h12M4 8h8M6 12h4"/>
                                </svg>
                                Filters
                            </button>
                        </div>
                        <div class="filter-tray" id="filterTray" style="display: none;">
                            <div class="filter-section">
                                <label class="filter-label">Source</label>
                                <div class="checkbox-group" id="sourceFilters"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Author</label>
                                <div class="checkbox-group" id="authorFilters"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Concept/Topic/Term</label>
                                <input type="text" class="autocomplete-input" id="conceptFilterInput" placeholder="Type to search concepts, topics, or terms..." oninput="handleConceptAutocomplete(event)" onkeydown="handleAutocompleteKeydown(event, 'concept')">
                                <div class="autocomplete-dropdown" id="conceptAutocomplete"></div>
                                <div class="selected-filters" id="selectedConcepts"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Discourse Elements</label>
                                <input type="text" class="autocomplete-input" id="discourseFilterInput" placeholder="Type to search discourse elements..." oninput="handleDiscourseAutocomplete(event)" onkeydown="handleAutocompleteKeydown(event, 'discourse')">
                                <div class="autocomplete-dropdown" id="discourseAutocomplete"></div>
                                <div class="selected-filters" id="selectedDiscourse"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Scripture References</label>
                                <input type="text" class="autocomplete-input" id="scriptureFilterInput" placeholder="Type to search scripture references..." oninput="handleScriptureAutocomplete(event)" onkeydown="handleAutocompleteKeydown(event, 'scripture')">
                                <div class="autocomplete-dropdown" id="scriptureAutocomplete"></div>
                                <div class="selected-filters" id="selectedScripture"></div>
                            </div>
                            <div class="filter-section">
                                <label class="filter-label">Named Entities</label>
                                <input type="text" class="autocomplete-input" id="entityFilterInput" placeholder="Type to search named entities..." oninput="handleEntityAutocomplete(event)" onkeydown="handleAutocompleteKeydown(event, 'entity')">
                                <div class="autocomplete-dropdown" id="entityAutocomplete"></div>
                                <div class="selected-filters" id="selectedEntities"></div>
                            </div>
                            <div class="filter-actions">
                                <button class="search-btn" onclick="applyFilters()">Apply Filters</button>
                                <button class="search-btn" onclick="clearFilters()" style="background: #6c757d;">Clear All</button>
                            </div>
                        </div>
                        <div class="panel-content" id="draftSourcesContent"></div>
                    </div>

                    <div class="panel history-panel">
                        <div class="panel-header">
                            Draft History
                            <button class="clear-history-btn" onclick="clearDraftHistory()">Clear All</button>
                        </div>
                        <div class="panel-content">
                            <div class="search-history-list" id="draftHistoryList">
                                <div class="no-results">No saved drafts yet</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content" id="mainContent" style="display: none;">
            <div class="panel">
                <div class="panel-header">Research Summary</div>
                <div class="panel-content" id="researchContent"></div>
            </div>

            <div class="panel">
                <div class="panel-header">Sources & Citations</div>
                <div class="panel-content" id="sourcesContent"></div>
            </div>

            <div class="panel history-panel" id="historyPanel" style="display: none;">
                <div class="panel-header">
                    Search History
                    <button class="clear-history-btn" onclick="clearSearchHistory()">Clear All</button>
                </div>
                <div class="panel-content">
                    <div id="sourceSelectionSection" style="display: none;">
                        <div style="font-weight: 600; margin-bottom: 8px; font-size: 12px;">Select Sources:</div>
                        <div id="sourcesList"></div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                            <button class="history-btn" onclick="selectAllSources()">All</button>
                            <button class="history-btn" onclick="selectNoSources()">None</button>
                            <button class="history-btn" onclick="applySourceSelection()">Apply</button>
                        </div>
                    </div>
                    <div id="searchHistorySection">
                        <div class="search-history-list" id="searchHistoryList">
                            <div class="no-results">No saved searches yet</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentSources = [];
        let availableSources = [];
        let selectedSources = new Set();
        let searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');
        let draftHistory = JSON.parse(localStorage.getItem('draftHistory') || '[]');
        let currentSearchResult = null;
        let currentLayout = 'research';
        let currentDraftCitations = null;
        let draftAutosaveTimer = null;
        let currentDraftId = null; // Track which draft is currently being edited
        
        // Clean up old drafts that have full chunks stored (to avoid quota issues)
        // Migrate old format to new format (only store chunk_ids, not full chunks)
        let needsDraftMigration = false;
        for (let draft of draftHistory) {
            if (draft.citations && draft.citations.chunks && Array.isArray(draft.citations.chunks) && draft.citations.chunks.length > 0) {
                // This draft has full chunks stored - migrate to new format
                draft.citations = {
                    sources_used: draft.citations.sources_used || [],
                    chunk_ids: draft.citations.chunks.map(c => {
                        if (typeof c === 'object' && c !== null) {
                            return c.id || c.get?.('id') || null;
                        }
                        return null;
                    }).filter(id => id !== null)
                };
                needsDraftMigration = true;
            }
        }
        if (needsDraftMigration) {
            try {
                localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                console.log('Migrated old draft format to new format (removed full chunks)');
            } catch (e) {
                console.warn('Could not migrate drafts:', e);
            }
        }
        
        // Clean up old search history that has full chunks stored (to avoid quota issues)
        // Migrate old format to new format (only store chunk_ids, not full chunks)
        let needsSearchMigration = false;
        for (let search of searchHistory) {
            if (search.chunks && Array.isArray(search.chunks) && search.chunks.length > 0 && !search.chunk_ids) {
                // This search has full chunks stored - migrate to new format
                search.chunk_ids = search.chunks.map(c => {
                    if (typeof c === 'object' && c !== null) {
                        return c.id || c.get?.('id') || null;
                    }
                    return null;
                }).filter(id => id !== null);
                delete search.chunks; // Remove full chunks to save space
                needsSearchMigration = true;
            }
        }
        if (needsSearchMigration) {
            try {
                localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                console.log('Migrated old search format to new format (removed full chunks)');
            } catch (e) {
                console.warn('Could not migrate search history:', e);
            }
        }

        // Initialize the interface
        document.addEventListener('DOMContentLoaded', function() {
            loadAvailableSources();
            displaySearchHistory();
            displayDraftHistory();
            // Ensure the new layout is visible on load
            try {
                document.getElementById('layoutContainer').style.display = 'flex';
                switchLayout('research');
            } catch (e) {
                console.warn('Layout init warning:', e);
            }
            // Draft layout starts empty - no autosave restoration
            
            // Handle Enter key in search input
            document.getElementById('queryInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    performSearch();
                }
            });
            
            // Autosave on draft input (debounced)
            const draftTA = document.getElementById('draftTextarea');
            draftTA.addEventListener('input', () => {
                scheduleDraftAutosave();
            });

            // Handle source stack selection
            document.getElementById('sourceStack').addEventListener('change', function() {
                if (this.value === 'custom') {
                    showSourceSelection();
                } else {
                    hideSourceSelection();
                    selectedSources.clear();
                    availableSources.forEach(source => selectedSources.add(source.id));
                }
            });
        });

        function loadAvailableSources() {
            // Fetch available sources from API
            fetch('/api/sources')
                .then(response => response.json())
                .then(sources => {
                    availableSources = sources;
                    
                    // Initialize with all sources selected
                    selectedSources.clear();
                    availableSources.forEach(source => selectedSources.add(source.id));
                    
                    updateSourcesList();
                })
                .catch(error => {
                    console.error('Error loading sources:', error);
                    // Fallback: show error message
                    availableSources = [];
                    selectedSources.clear();
                    updateSourcesList();
                });
        }

        function updateSourcesList() {
            const sourcesList = document.getElementById('sourcesList');
            sourcesList.innerHTML = '';
            
            availableSources.forEach(source => {
                const item = document.createElement('div');
                item.className = 'source-list-item';
                item.innerHTML = `
                    <label>
                        <input type="checkbox" class="source-checkbox" 
                               ${selectedSources.has(source.id) ? 'checked' : ''} 
                               onchange="toggleSourceSelection('${source.id}')">
                        <span>${source.name}</span>
                        <span class="source-count">(${source.chunkCount})</span>
                    </label>
                `;
                sourcesList.appendChild(item);
            });
        }

        function showSourceSelection() {
            document.getElementById('sourceSelectionSection').style.display = 'block';
            document.getElementById('searchHistorySection').style.display = 'none';
            document.getElementById('historyPanel').style.display = 'block';
        }

        function hideSourceSelection() {
            document.getElementById('sourceSelectionSection').style.display = 'none';
            document.getElementById('searchHistorySection').style.display = 'block';
        }

        function toggleSourceSelection(sourceId) {
            if (selectedSources.has(sourceId)) {
                selectedSources.delete(sourceId);
            } else {
                selectedSources.add(sourceId);
            }
        }

        function selectAllSources() {
            selectedSources.clear();
            availableSources.forEach(source => selectedSources.add(source.id));
            updateSourcesList();
        }

        function selectNoSources() {
            selectedSources.clear();
            updateSourcesList();
        }

        function applySourceSelection() {
            document.getElementById('sourceStack').value = selectedSources.size === availableSources.length ? 'all' : 'custom';
            hideSourceSelection();
        }


        function saveCurrentSearch() {
            if (!currentSearchResult) return;
            
            const searchEntry = {
                id: Date.now(),
                query: document.getElementById('queryInput').value.trim(),
                timestamp: new Date().toISOString(),
                summary: currentSearchResult.summary,
                sources: currentSearchResult.sources_used,
                reasoning: currentSearchResult.reasoning_transparency,
                sourceSelection: Array.from(selectedSources),
                // Store only chunk IDs to avoid localStorage quota issues
                // Don't store full chunks (they contain embeddings and are huge)
                chunk_ids: currentSearchResult.chunks ? currentSearchResult.chunks.map(c => c.id || c.get?.('id')) : []
            };
            
            searchHistory.unshift(searchEntry);
            
            // Keep only last 20 searches to avoid quota issues
            if (searchHistory.length > 20) {
                searchHistory = searchHistory.slice(0, 20);
            }
            
            // Try to save, with error handling for quota issues
            try {
                localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
            } catch (e) {
                if (e.name === 'QuotaExceededError' || e.message.includes('quota')) {
                    // If quota exceeded, try removing oldest searches
                    console.warn('localStorage quota exceeded, removing oldest searches');
                    while (searchHistory.length > 10) {
                        searchHistory.pop(); // Remove oldest
                    }
                    try {
                        localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                        alert('Search saved, but some older searches were removed due to storage limits.');
                    } catch (e2) {
                        // Still failed - try with even fewer
                        searchHistory = searchHistory.slice(0, 5);
                        localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
                        alert('Search saved, but many older searches were removed due to storage limits.');
                    }
                } else {
                    throw e; // Re-throw if it's a different error
                }
            }
            
            displaySearchHistory();
            document.getElementById('saveSearchBtn').disabled = true;
        }

        function displaySearchHistory() {
            const historyList = document.getElementById('searchHistoryList');
            
            if (searchHistory.length === 0) {
                historyList.innerHTML = '<div class="no-results">No saved searches yet</div>';
                return;
            }
            
            historyList.innerHTML = searchHistory.map(entry => `
                <div class="history-item" onclick="loadSearchFromHistory(${entry.id})">
                    <div class="history-query">${entry.query}</div>
                    <div class="history-meta">
                        ${new Date(entry.timestamp).toLocaleDateString()} â€¢ ${entry.sources.length} sources
                    </div>
                </div>
            `).join('');
        }

        function loadSearchFromHistory(searchId) {
            const entry = searchHistory.find(s => s.id === searchId);
            if (!entry) return;
            
            // Restore the search
            document.getElementById('queryInput').value = entry.query;
            
            // Restore source selection
            selectedSources.clear();
            entry.sourceSelection.forEach(sourceId => selectedSources.add(sourceId));
            document.getElementById('sourceStack').value = selectedSources.size === availableSources.length ? 'all' : 'custom';
            
            // Display the saved results
            // Note: Full chunks are no longer stored to avoid quota issues
            // Only summary, sources, and reasoning are available
            displaySearchResults({
                summary: entry.summary,
                sources_used: entry.sources,
                reasoning_transparency: entry.reasoning,
                chunks: entry.chunks || [] // Old format - check if chunks exist for backwards compatibility
            });
            // Ensure only the new layout is visible
            document.getElementById('layoutContainer').style.display = 'flex';
            document.getElementById('researchLayout').style.display = 'grid';
            document.getElementById('draftLayout').style.display = 'none';
            // Hide legacy container to avoid double panels
            const legacyMain = document.getElementById('mainContent');
            if (legacyMain) legacyMain.style.display = 'none';
            
            document.getElementById('saveSearchBtn').disabled = true;
            currentSearchResult = entry;
        }

        function clearSearchHistory() {
            if (confirm('Are you sure you want to clear all search history?')) {
                searchHistory = [];
                localStorage.removeItem('searchHistory');
                displaySearchHistory();
            }
        }

        function saveDraft() {
            try {
                const textarea = document.getElementById('draftTextarea');
                if (!textarea) {
                    console.error('Draft textarea not found');
                    alert('Error: Could not find draft textarea.');
                    return;
                }
                
                const draftText = textarea.value.trim();
                
                if (!draftText) {
                    alert('Please write some content before saving the draft.');
                    return;
                }
                
                // Check if we should update existing draft or create new one
                let draftEntry;
                let isUpdate = false;
                
                if (currentDraftId) {
                    // Update existing draft
                    const existingIndex = draftHistory.findIndex(d => d.id === currentDraftId);
                    if (existingIndex !== -1) {
                        draftEntry = draftHistory[existingIndex];
                        draftEntry.title = draftText.substring(0, 50) + (draftText.length > 50 ? '...' : '');
                        draftEntry.content = draftText;
                        draftEntry.date = new Date().toLocaleDateString();
                        draftEntry.wordCount = draftText.split(/\s+/).length;
                        // Store only minimal citation data to avoid localStorage quota issues
                        // Don't store full chunks (they contain embeddings and are huge)
                        draftEntry.citations = currentDraftCitations ? {
                            sources_used: currentDraftCitations.sources_used || [],
                            // Store only chunk IDs, not full chunk objects
                            chunk_ids: currentDraftCitations.chunks ? currentDraftCitations.chunks.map(c => c.id || c.get?.('id')) : []
                        } : null;
                        // Move to top
                        draftHistory.splice(existingIndex, 1);
                        draftHistory.unshift(draftEntry);
                        isUpdate = true;
                    } else {
                        currentDraftId = null; // Draft was deleted, create new
                    }
                }
                
                if (!isUpdate) {
                    // Create new draft
                    draftEntry = {
                        id: Date.now(),
                        title: draftText.substring(0, 50) + (draftText.length > 50 ? '...' : ''),
                        content: draftText,
                        date: new Date().toLocaleDateString(),
                        wordCount: draftText.split(/\s+/).length,
                        // Store only minimal citation data to avoid localStorage quota issues
                        // Don't store full chunks (they contain embeddings and are huge)
                        citations: currentDraftCitations ? {
                            sources_used: currentDraftCitations.sources_used || [],
                            // Store only chunk IDs, not full chunk objects
                            chunk_ids: currentDraftCitations.chunks ? currentDraftCitations.chunks.map(c => c.id || c.get?.('id')) : []
                        } : null
                    };
                    draftHistory.unshift(draftEntry);
                    currentDraftId = draftEntry.id;
                }
                
                // Limit to fewer drafts to avoid localStorage quota issues
                if (draftHistory.length > 20) {
                    draftHistory = draftHistory.slice(0, 20); // Keep only last 20 drafts
                }
                
                // Try to save, with error handling for quota issues
                try {
                    localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                } catch (e) {
                    if (e.name === 'QuotaExceededError' || e.message.includes('quota')) {
                        // If quota exceeded, try removing oldest drafts
                        console.warn('localStorage quota exceeded, removing oldest drafts');
                        while (draftHistory.length > 10) {
                            draftHistory.pop(); // Remove oldest
                        }
                        try {
                            localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                            alert('Draft saved, but some older drafts were removed due to storage limits.');
                        } catch (e2) {
                            // Still failed - try with even fewer
                            draftHistory = draftHistory.slice(0, 5);
                            localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                            alert('Draft saved, but many older drafts were removed due to storage limits.');
                        }
                    } else {
                        throw e; // Re-throw if it's a different error
                    }
                }
                
                // Ensure draftHistoryList element exists before calling displayDraftHistory
                const historyList = document.getElementById('draftHistoryList');
                if (historyList) {
                    displayDraftHistory();
                } else {
                    console.warn('draftHistoryList element not found, but draft was saved to localStorage');
                }
                
                // Update autosave snapshot
                persistDraftAutosave();
                
                // Show feedback
                const btn = document.getElementById('saveDraftBtn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = 'Saved!';
                    btn.style.background = '#d4edda';
                    btn.style.color = '#155724';
                    
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#4a90e2';
                        btn.style.color = 'white';
                    }, 1000);
                }
            } catch (error) {
                console.error('Error saving draft:', error);
                alert('Error saving draft: ' + error.message);
            }
        }

        function displayDraftHistory() {
            try {
                const historyList = document.getElementById('draftHistoryList');
                if (!historyList) {
                    console.warn('draftHistoryList element not found');
                    return;
                }
                
                if (!draftHistory || draftHistory.length === 0) {
                    historyList.innerHTML = '<div class="no-results">No saved drafts yet</div>';
                    return;
                }
                
                historyList.innerHTML = draftHistory.map(draft => {
                    const title = (draft.title || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const date = draft.date || 'Unknown date';
                    const wordCount = draft.wordCount || 0;
                    const sourceCount = draft.citations && draft.citations.sources_used ? draft.citations.sources_used.length : 0;
                    return `
                        <div class="history-item">
                            <div onclick="loadDraft(${draft.id})" style="flex: 1; cursor: pointer;">
                                <div class="history-title">${title}</div>
                                <div class="history-meta">${date} â€¢ ${wordCount} words${sourceCount > 0 ? ` â€¢ ${sourceCount} sources` : ''}</div>
                            </div>
                            <button class="delete-draft-btn" onclick="event.stopPropagation(); deleteDraft(${draft.id})" title="Delete draft">Ã—</button>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Error displaying draft history:', error);
            }
        }

        function loadDraft(draftId) {
            const draft = draftHistory.find(d => d.id === draftId);
            if (!draft) return;
            
            document.getElementById('draftTextarea').value = draft.content;
            currentDraftId = draftId; // Set current draft ID so we can update it
            
            if (draft.citations) {
                // Citations now store only sources_used and chunk_ids, not full chunks
                // Display what we have (sources_used), but full chunks won't be available
                currentDraftCitations = {
                    sources_used: draft.citations.sources_used || [],
                    chunks: [] // Full chunks not stored to avoid quota issues
                };
                displayDraftSearchResults(currentDraftCitations);
            } else {
                currentDraftCitations = null;
                document.getElementById('draftSourcesContent').innerHTML = '';
            }
            
            // Switch to draft layout if not already there
            if (currentLayout !== 'draft') {
                switchLayout('draft');
            }
            scheduleDraftAutosave();
        }

        function deleteDraft(draftId) {
            // Remove from history
            const index = draftHistory.findIndex(d => d.id === draftId);
            if (index !== -1) {
                draftHistory.splice(index, 1);
                localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                displayDraftHistory();
                
                // If this was the current draft being edited, clear it
                if (currentDraftId === draftId) {
                    document.getElementById('draftTextarea').value = '';
                    currentDraftId = null;
                    currentDraftCitations = null;
                    document.getElementById('draftSourcesContent').innerHTML = '';
                    localStorage.removeItem('draftAutosave');
                }
            }
        }

        function newDraft() {
            // Clear current draft state
            document.getElementById('draftTextarea').value = '';
            currentDraftId = null;
            currentDraftCitations = null;
            document.getElementById('draftSourcesContent').innerHTML = '';
            
            // Clear autosave
            localStorage.removeItem('draftAutosave');
            
            // Switch to draft layout if not already there
            if (currentLayout !== 'draft') {
                switchLayout('draft');
            }
        }

        function clearDraftHistory() {
            if (confirm('Are you sure you want to clear all draft history?')) {
                draftHistory = [];
                localStorage.removeItem('draftHistory');
                displayDraftHistory();
            }
        }

        function scheduleDraftAutosave() {
            if (draftAutosaveTimer) clearTimeout(draftAutosaveTimer);
            draftAutosaveTimer = setTimeout(() => {
                persistDraftAutosave();
            }, 800);
        }

        function persistDraftAutosave() {
            try {
                const content = document.getElementById('draftTextarea').value.trim();
                
                // Only autosave if there's actual content and we have a currentDraftId
                if (!content || !currentDraftId) {
                    // Just store to autosave key for session persistence (not restored on page load)
                    const snapshot = {
                        content,
                        citations: currentDraftCitations,
                        timestamp: Date.now(),
                        draftId: currentDraftId
                    };
                    localStorage.setItem('draftAutosave', JSON.stringify(snapshot));
                    return;
                }
                
                // Update existing draft if we have a currentDraftId
                const existingIndex = draftHistory.findIndex(d => d.id === currentDraftId);
                if (existingIndex !== -1) {
                    const draft = draftHistory[existingIndex];
                    draft.content = content;
                    draft.title = content.substring(0, 50) + (content.length > 50 ? '...' : '');
                    draft.wordCount = content.split(/\s+/).length;
                    draft.citations = currentDraftCitations ? {
                        sources_used: currentDraftCitations.sources_used || [],
                        chunks: currentDraftCitations.chunks || []
                    } : null;
                    // Keep in place (don't move to top on autosave)
                    localStorage.setItem('draftHistory', JSON.stringify(draftHistory));
                } else {
                    currentDraftId = null; // Draft was deleted
                }
            } catch (e) {
                console.error('Autosave error:', e);
            }
        }

        function switchLayout(layout) {
            currentLayout = layout;
            
            // Update layout icons
            document.getElementById('researchIcon').classList.toggle('active', layout === 'research');
            document.getElementById('draftIcon').classList.toggle('active', layout === 'draft');
            
            // Show/hide layouts
            if (layout === 'research') {
                document.getElementById('researchLayout').style.display = 'grid';
                document.getElementById('researchLayout').style.gridTemplateColumns = '2fr 1fr 200px';
                document.getElementById('draftLayout').style.display = 'none';
            } else if (layout === 'draft') {
                document.getElementById('draftLayout').style.display = 'grid';
                document.getElementById('draftLayout').style.gridTemplateColumns = '2fr 1fr 200px';
                document.getElementById('researchLayout').style.display = 'none';
            }
            
            // Show layout container
            document.getElementById('layoutContainer').style.display = 'flex';
            
            // Hide old main content if it exists
            document.getElementById('mainContent').style.display = 'none';
        }

        function findCitationsForDraft() {
            const textarea = document.getElementById('draftTextarea');
            const text = textarea.value;
            const cursorPos = textarea.selectionStart;
            
            if (!text.trim()) {
                alert('Please write some content first before searching for citations.');
                return;
            }
            
            // Extract context around cursor (5 sentences) and get position info
            const contextResult = extractContextAroundCursor(text, cursorPos);
            
            if (!contextResult.context || !contextResult.context.trim()) {
                alert('Could not extract enough context around cursor position.');
                return;
            }
            
            // Highlight the context text in the textarea
            if (contextResult.startPos !== undefined && contextResult.endPos !== undefined) {
                // Set selection to highlight the context
                textarea.focus();
                textarea.setSelectionRange(contextResult.startPos, contextResult.endPos);
                
                // Store the highlight info so we can clear it later if needed
                textarea.dataset.highlightedContext = 'true';
                textarea.dataset.highlightStart = contextResult.startPos;
                textarea.dataset.highlightEnd = contextResult.endPos;
            }
            
            // Show loading
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            
            // Perform context search
            fetch('/api/search-context', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    context_text: contextResult.context,
                    selected_sources: Array.from(selectedSources)
                })
            })
            .then(response => response.json())
            .then(data => {
                displayDraftSearchResults(data);
                currentDraftCitations = data;
                scheduleDraftAutosave();
            })
            .catch(error => {
                console.error('Context search error:', error);
                document.getElementById('draftSourcesContent').innerHTML = `
                    <div class="error">Error: ${error.message}</div>
                `;
            })
            .finally(() => {
                loading.style.display = 'none';
            });
        }

        function extractContextAroundCursor(text, cursorPos) {
            // Find sentence boundaries using regex
            const sentenceRegex = /[.!?]+(?:\s+|$)/g;
            const sentences = [];
            const sentencePositions = [];
            let lastIndex = 0;
            let match;
            
            // Find all sentence boundaries
            while ((match = sentenceRegex.exec(text)) !== null) {
                const sentenceEnd = match.index + match[0].length;
                sentences.push(text.substring(lastIndex, sentenceEnd));
                sentencePositions.push({
                    start: lastIndex,
                    end: sentenceEnd
                });
                lastIndex = sentenceEnd;
            }
            
            // Add the last sentence if there's text after the last punctuation
            if (lastIndex < text.length) {
                sentences.push(text.substring(lastIndex));
                sentencePositions.push({
                    start: lastIndex,
                    end: text.length
                });
            }
            
            if (sentences.length === 0) {
                return { context: '', startPos: 0, endPos: 0 };
            }
            
            // Find which sentence the cursor is in
            let currentSentenceIndex = 0;
            for (let i = 0; i < sentencePositions.length; i++) {
                if (cursorPos >= sentencePositions[i].start && cursorPos <= sentencePositions[i].end) {
                    currentSentenceIndex = i;
                    break;
                }
            }
            
            // Extract 2 sentences before, current sentence, and 2 sentences after
            const startIndex = Math.max(0, currentSentenceIndex - 2);
            const endIndex = Math.min(sentences.length, currentSentenceIndex + 3);
            
            const startPos = sentencePositions[startIndex].start;
            const endPos = sentencePositions[endIndex - 1].end;
            
            // Extract context and trim for API, but keep original positions for highlighting
            let contextText = text.substring(startPos, endPos);
            // Trim whitespace but track how much we trimmed for accurate highlighting
            const originalLength = contextText.length;
            const trimmedText = contextText.trim();
            const trimmedStart = contextText.length - contextText.replace(/^\s+/, '').length;
            const trimmedEnd = originalLength - trimmedStart - trimmedText.length;
            const actualStartPos = startPos + trimmedStart;
            const actualEndPos = endPos - trimmedEnd;
            contextText = trimmedText;
            
            return {
                context: contextText,
                startPos: actualStartPos,
                endPos: actualEndPos
            };
        }

        function displayDraftSearchResults(data) {
            const sourcesContent = document.getElementById('draftSourcesContent');
            
            // Store sources for citation handling
            currentSources = data.sources_used || [];
            currentDraftCitations = data;
            
            // Display sources with copy options
            let sourcesHtml = '';
            if (currentSources.length > 0) {
                sourcesHtml = currentSources.map((source, index) => {
                    const chunk = data.chunks ? data.chunks[index] : null;
                    // Build metadata tooltip
                    const metadata = chunk ? (chunk.metadata || {}) : {};
                    let tooltipContent = '';
                    
                    if (metadata.topics && metadata.topics.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Topics</div><div class="metadata-values">${metadata.topics.join(', ')}</div></div>`;
                    }
                    if (metadata.concepts && metadata.concepts.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Concepts</div><div class="metadata-values">${metadata.concepts.join(', ')}</div></div>`;
                    }
                    if (metadata.terms && metadata.terms.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Terms</div><div class="metadata-values">${metadata.terms.join(', ')}</div></div>`;
                    }
                    if (metadata.discourse_elements && metadata.discourse_elements.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Discourse Elements</div><div class="metadata-values">${metadata.discourse_elements.join(', ')}</div></div>`;
                    }
                    if (metadata.scripture_references && metadata.scripture_references.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Scripture References</div><div class="metadata-values">${metadata.scripture_references.join(', ')}</div></div>`;
                    }
                    if (metadata.named_entities && metadata.named_entities.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Named Entities</div><div class="metadata-values">${metadata.named_entities.join(', ')}</div></div>`;
                    }
                    if (metadata.structure_path) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Location</div><div class="metadata-values">${metadata.structure_path}</div></div>`;
                    }
                    
                    const chunkText = chunk ? chunk.text : '';
                    const citationText = `(${source.source || 'Unknown'}, ${source.author || 'Unknown'})`;
                    const encodedText = encodeURIComponent(chunkText);
                    const encodedCitation = encodeURIComponent(citationText);
                    
                    return `
                        <div class="source-item" id="source-${source.number}">
                            <div class="source-header">
                                <div class="source-number">${source.number}</div>
                                <div class="source-title">${source.source || 'Unknown'}</div>
                                ${tooltipContent ? `
                                <div class="metadata-tooltip">
                                    <span style="cursor: help; color: #666;">â“˜</span>
                                    <div class="tooltip-content">${tooltipContent}</div>
                                </div>
                                ` : ''}
                            </div>
                            <div class="source-meta">
                                <strong>Author:</strong> ${source.author || 'Unknown'}<br>
                                <strong>Location:</strong> ${source.location || 'Unknown'}
                            </div>
                            <div class="source-text">${chunkText || 'Text not available'}</div>
                            ${source.relevance ? `<div class="source-relevance"><strong>Relevance:</strong> ${source.relevance}</div>` : ''}
                            <div class="copy-options">
                                <button class="copy-btn" data-text="${encodedText}" onclick="copyToClipboard(event)">Copy Text</button>
                                <button class="copy-btn" data-text="${encodedCitation}" onclick="copyToClipboard(event)">Copy Citation</button>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                sourcesHtml = '<div class="no-results">No sources found</div>';
            }
            
            sourcesContent.innerHTML = sourcesHtml;
            scheduleDraftAutosave();
        }

        // Filter functionality
        let filterOptions = null;
        let selectedFilters = {
            sources: [],
            authors: [],
            concepts: [],
            topics: [],
            terms: [],
            discourse_elements: [],
            scripture_references: [],
            named_entities: []
        };

        async function loadFilterOptions() {
            try {
                const response = await fetch('/api/filter-options');
                if (response.ok) {
                    filterOptions = await response.json();
                    populateFilters();
                } else {
                    console.error('Failed to load filter options');
                }
            } catch (error) {
                console.error('Error loading filter options:', error);
            }
        }

        function populateFilters() {
            if (!filterOptions) return;

            // Populate source checkboxes
            const sourceContainer = document.getElementById('sourceFilters');
            sourceContainer.innerHTML = filterOptions.sources.map(source => `
                <div class="checkbox-item">
                    <input type="checkbox" id="source-${source.replace(/[^a-zA-Z0-9]/g, '_')}" value="${source}" onchange="updateSourceFilter('${source}', this.checked)">
                    <label for="source-${source.replace(/[^a-zA-Z0-9]/g, '_')}">${source}</label>
                </div>
            `).join('');

            // Populate author checkboxes
            const authorContainer = document.getElementById('authorFilters');
            authorContainer.innerHTML = filterOptions.authors.map(author => `
                <div class="checkbox-item">
                    <input type="checkbox" id="author-${author.replace(/[^a-zA-Z0-9]/g, '_')}" value="${author}" onchange="updateAuthorFilter('${author}', this.checked)">
                    <label for="author-${author.replace(/[^a-zA-Z0-9]/g, '_')}">${author}</label>
                </div>
            `).join('');
        }

        function updateSourceFilter(source, checked) {
            if (checked) {
                if (!selectedFilters.sources.includes(source)) {
                    selectedFilters.sources.push(source);
                }
            } else {
                selectedFilters.sources = selectedFilters.sources.filter(s => s !== source);
            }
        }

        function updateAuthorFilter(author, checked) {
            if (checked) {
                if (!selectedFilters.authors.includes(author)) {
                    selectedFilters.authors.push(author);
                }
            } else {
                selectedFilters.authors = selectedFilters.authors.filter(a => a !== author);
            }
        }

        function toggleFilterTray() {
            const tray = document.getElementById('filterTray');
            const isVisible = tray.style.display !== 'none';
            tray.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible && !filterOptions) {
                loadFilterOptions();
            }
        }

        function handleConceptAutocomplete(event) {
            const input = event.target.value.toLowerCase();
            const dropdown = document.getElementById('conceptAutocomplete');
            const inputEl = event.target;
            
            if (!filterOptions || !input) {
                dropdown.classList.remove('show');
                return;
            }

            const matches = [];
            
            // Search concepts, topics, and terms
            for (const [concept, related] of Object.entries(filterOptions.concept_suggestions)) {
                const conceptLower = concept.toLowerCase();
                if (conceptLower.includes(input)) {
                    matches.push({ type: 'concept', value: concept, display: concept, related: related });
                }
                
                // Also check related topics and terms
                for (const topic of related.topics || []) {
                    if (topic.toLowerCase().includes(input)) {
                        matches.push({ type: 'topic', value: topic, display: topic, concept: concept });
                    }
                }
                for (const term of related.terms || []) {
                    if (term.toLowerCase().includes(input)) {
                        matches.push({ type: 'term', value: term, display: term, concept: concept });
                    }
                }
            }

            // Sort: concepts first, then topics/terms grouped by concept
            matches.sort((a, b) => {
                if (a.type === 'concept' && b.type !== 'concept') return -1;
                if (a.type !== 'concept' && b.type === 'concept') return 1;
                if (a.type === 'concept') return a.value.localeCompare(b.value);
                if (a.concept === b.concept) return a.value.localeCompare(b.value);
                return a.concept.localeCompare(b.concept);
            });

            // Build dropdown HTML
            let html = '';
            let lastConcept = null;
            for (const match of matches.slice(0, 20)) { // Limit to 20 results
                // Clean display text - remove [[ and ]]
                const displayText = match.display.replace(/^\[\[/, '').replace(/\]\]$/, '');
                const conceptDisplay = match.concept ? match.concept.replace(/^\[\[/, '').replace(/\]\]$/, '') : '';
                
                if (match.type === 'concept') {
                    if (lastConcept !== null) html += '</div>';
                    html += `<div class="autocomplete-item concept-header" data-value="${match.value.replace(/"/g, '&quot;')}" data-type="concept">${displayText}</div>`;
                    lastConcept = match.value;
                } else {
                    if (lastConcept !== match.concept) {
                        if (lastConcept !== null) html += '</div>';
                        html += `<div class="autocomplete-item concept-header">${conceptDisplay}</div>`;
                        lastConcept = match.concept;
                    }
                    html += `<div class="autocomplete-item concept-related" data-value="${match.value.replace(/"/g, '&quot;')}" data-type="${match.type}">${displayText}</div>`;
                }
            }
            if (lastConcept !== null) html += '</div>';

            dropdown.innerHTML = html;
            
            // Position dropdown below input field
            // Find input's position relative to filter-section
            const filterSection = inputEl.closest('.filter-section');
            const label = filterSection.querySelector('.filter-label');
            const labelHeight = label ? label.offsetHeight + 6 : 0; // 6px is margin-bottom
            const inputTop = labelHeight;
            
            dropdown.style.position = 'absolute';
            dropdown.style.top = (inputTop + inputEl.offsetHeight + 2) + 'px';
            dropdown.style.left = '0px';
            dropdown.style.width = inputEl.offsetWidth + 'px';
            
            dropdown.classList.add('show');
            
            // Add event listeners to dropdown items
            dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = item.getAttribute('data-value');
                    const type = item.getAttribute('data-type');
                    
                    // Skip header items (they don't have data-value or have empty data-type)
                    if (value) {
                        selectConceptFilter(value, type || 'concept');
                    }
                });
            });
        }

        function handleDiscourseAutocomplete(event) {
            const input = event.target.value.toLowerCase();
            const dropdown = document.getElementById('discourseAutocomplete');
            const inputEl = event.target;
            
            if (!filterOptions || !input) {
                dropdown.classList.remove('show');
                return;
            }

            const matches = [];
            
            // Search both namespaces and specific elements
            // discourse_suggestions now contains tags (not full strings)
            for (const [namespace, tags] of Object.entries(filterOptions.discourse_suggestions)) {
                const nsLower = namespace.toLowerCase();
                const namespaceMatches = nsLower.includes(input);
                
                // Check if namespace matches
                if (namespaceMatches) {
                    matches.push({ type: 'namespace', value: namespace, display: namespace });
                }
                
                // Check specific tags within this namespace
                for (const tag of tags || []) {
                    // tag is already just the tag (e.g., "Logical/Claim"), not a full string
                    if (tag.toLowerCase().includes(input)) {
                        matches.push({ type: 'element', value: tag, display: tag, namespace: namespace });
                    }
                }
            }

            // Sort: namespaces first, then elements grouped by namespace
            matches.sort((a, b) => {
                if (a.type === 'namespace' && b.type !== 'namespace') return -1;
                if (a.type !== 'namespace' && b.type === 'namespace') return 1;
                if (a.type === 'namespace') return a.value.localeCompare(b.value);
                if (a.namespace === b.namespace) return a.value.localeCompare(b.value);
                return a.namespace.localeCompare(b.namespace);
            });

            let html = '';
            let lastNamespace = null;
            for (const match of matches.slice(0, 20)) {
                // Tags are already clean (no brackets), just use them as-is
                const displayText = match.display;
                const namespaceDisplay = match.namespace || '';
                
                if (match.type === 'namespace') {
                    if (lastNamespace !== null) html += '</div>';
                    html += `<div class="autocomplete-item concept-header" data-value="${match.value.replace(/"/g, '&quot;')}" data-filter-type="discourse">${displayText}</div>`;
                    lastNamespace = match.value;
                } else {
                    if (lastNamespace !== match.namespace) {
                        if (lastNamespace !== null) html += '</div>';
                        html += `<div class="autocomplete-item concept-header">${namespaceDisplay}</div>`;
                        lastNamespace = match.namespace;
                    }
                    html += `<div class="autocomplete-item concept-related" data-value="${match.value.replace(/"/g, '&quot;')}" data-filter-type="discourse">${displayText}</div>`;
                }
            }
            if (lastNamespace !== null) html += '</div>';

            dropdown.innerHTML = html;
            
            // Position dropdown below input field
            dropdown.style.position = 'absolute';
            dropdown.style.top = inputEl.offsetHeight + 2 + 'px';
            dropdown.style.left = '0px';
            dropdown.style.width = inputEl.offsetWidth + 'px';
            
            dropdown.classList.add('show');
            
            // Add event listeners to dropdown items
            dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = item.getAttribute('data-value');
                    const filterType = item.getAttribute('data-filter-type');
                    
                    if (filterType === 'discourse') {
                        selectDiscourseFilter(value);
                    }
                });
            });
        }

        function handleScriptureAutocomplete(event) {
            const input = event.target.value.toLowerCase();
            const dropdown = document.getElementById('scriptureAutocomplete');
            const inputEl = event.target;
            
            if (!filterOptions || !input) {
                dropdown.classList.remove('show');
                return;
            }

            const matches = filterOptions.scripture_references
                .filter(ref => ref.toLowerCase().includes(input))
                .slice(0, 20);

            dropdown.innerHTML = matches.map(ref => {
                const displayText = ref.replace(/^\[\[/, '').replace(/\]\]$/, '');
                return `<div class="autocomplete-item" data-value="${ref.replace(/"/g, '&quot;')}" data-filter-type="scripture">${displayText}</div>`;
            }).join('');
            
            // Position dropdown below input field
            dropdown.style.position = 'absolute';
            dropdown.style.top = inputEl.offsetHeight + 2 + 'px';
            dropdown.style.left = '0px';
            dropdown.style.width = inputEl.offsetWidth + 'px';
            
            dropdown.classList.add('show');
            
            // Add event listeners to dropdown items
            dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = item.getAttribute('data-value');
                    selectScriptureFilter(value);
                });
            });
        }

        function handleEntityAutocomplete(event) {
            const input = event.target.value.toLowerCase();
            const dropdown = document.getElementById('entityAutocomplete');
            const inputEl = event.target;
            
            if (!filterOptions || !input) {
                dropdown.classList.remove('show');
                return;
            }

            const matches = filterOptions.named_entities
                .filter(entity => entity.toLowerCase().includes(input))
                .slice(0, 20);

            dropdown.innerHTML = matches.map(entity => {
                const displayText = entity.replace(/^\[\[/, '').replace(/\]\]$/, '');
                return `<div class="autocomplete-item" data-value="${entity.replace(/"/g, '&quot;')}" data-filter-type="entity">${displayText}</div>`;
            }).join('');
            
            // Position dropdown below input field
            dropdown.style.position = 'absolute';
            dropdown.style.top = inputEl.offsetHeight + 2 + 'px';
            dropdown.style.left = '0px';
            dropdown.style.width = inputEl.offsetWidth + 'px';
            
            dropdown.classList.add('show');
            
            // Add event listeners to dropdown items
            dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = item.getAttribute('data-value');
                    const type = item.getAttribute('data-type');
                    const filterType = item.getAttribute('data-filter-type');
                    
                    if (filterType === 'discourse') {
                        selectDiscourseFilter(value);
                    } else if (filterType === 'scripture') {
                        selectScriptureFilter(value);
                    } else if (filterType === 'entity') {
                        selectEntityFilter(value);
                    } else {
                        // Concept/Topic/Term
                        selectConceptFilter(value, type);
                    }
                });
            });
        }

        function selectConceptFilter(value, type) {
            if (type === 'topic') {
                if (!selectedFilters.topics.includes(value)) {
                    selectedFilters.topics.push(value);
                }
            } else if (type === 'term') {
                if (!selectedFilters.terms.includes(value)) {
                    selectedFilters.terms.push(value);
                }
            } else {
                // Concept
                if (!selectedFilters.concepts.includes(value)) {
                    selectedFilters.concepts.push(value);
                }
            }
            updateSelectedFilters();
            document.getElementById('conceptFilterInput').value = '';
            document.getElementById('conceptAutocomplete').classList.remove('show');
        }

        function selectDiscourseFilter(value) {
            if (!selectedFilters.discourse_elements.includes(value)) {
                selectedFilters.discourse_elements.push(value);
            }
            updateSelectedFilters();
            document.getElementById('discourseFilterInput').value = '';
            document.getElementById('discourseAutocomplete').classList.remove('show');
        }

        function selectScriptureFilter(value) {
            if (!selectedFilters.scripture_references.includes(value)) {
                selectedFilters.scripture_references.push(value);
            }
            updateSelectedFilters();
            document.getElementById('scriptureFilterInput').value = '';
            document.getElementById('scriptureAutocomplete').classList.remove('show');
        }

        function selectEntityFilter(value) {
            if (!selectedFilters.named_entities.includes(value)) {
                selectedFilters.named_entities.push(value);
            }
            updateSelectedFilters();
            document.getElementById('entityFilterInput').value = '';
            document.getElementById('entityAutocomplete').classList.remove('show');
        }

        function updateSelectedFilters() {
            // Update concept/topic/term tags
            const container = document.getElementById('selectedConcepts');
            let html = '';
            selectedFilters.concepts.forEach(concept => {
                html += `<span class="filter-tag">${concept} <span class="remove-btn" onclick="removeConceptFilter('concept', '${concept.replace(/'/g, "\\'")}')">Ã—</span></span>`;
            });
            selectedFilters.topics.forEach(topic => {
                html += `<span class="filter-tag">${topic} <span class="remove-btn" onclick="removeConceptFilter('topic', '${topic.replace(/'/g, "\\'")}')">Ã—</span></span>`;
            });
            selectedFilters.terms.forEach(term => {
                html += `<span class="filter-tag">${term} <span class="remove-btn" onclick="removeConceptFilter('term', '${term.replace(/'/g, "\\'")}')">Ã—</span></span>`;
            });
            container.innerHTML = html;

            // Update discourse tags
            const discourseContainer = document.getElementById('selectedDiscourse');
            html = '';
            selectedFilters.discourse_elements.forEach(de => {
                html += `<span class="filter-tag">${de} <span class="remove-btn" onclick="removeFilter('discourse_elements', '${de.replace(/'/g, "\\'")}')">Ã—</span></span>`;
            });
            discourseContainer.innerHTML = html;

            // Update scripture tags
            const scriptureContainer = document.getElementById('selectedScripture');
            html = '';
            selectedFilters.scripture_references.forEach(ref => {
                html += `<span class="filter-tag">${ref} <span class="remove-btn" onclick="removeFilter('scripture_references', '${ref.replace(/'/g, "\\'")}')">Ã—</span></span>`;
            });
            scriptureContainer.innerHTML = html;

            // Update entity tags
            const entityContainer = document.getElementById('selectedEntities');
            html = '';
            selectedFilters.named_entities.forEach(entity => {
                html += `<span class="filter-tag">${entity} <span class="remove-btn" onclick="removeFilter('named_entities', '${entity.replace(/'/g, "\\'")}')">Ã—</span></span>`;
            });
            entityContainer.innerHTML = html;
        }

        function removeConceptFilter(type, value) {
            if (type === 'concept') {
                selectedFilters.concepts = selectedFilters.concepts.filter(c => c !== value);
            } else if (type === 'topic') {
                selectedFilters.topics = selectedFilters.topics.filter(t => t !== value);
            } else if (type === 'term') {
                selectedFilters.terms = selectedFilters.terms.filter(t => t !== value);
            }
            updateSelectedFilters();
        }

        function removeFilter(type, value) {
            if (selectedFilters[type]) {
                selectedFilters[type] = selectedFilters[type].filter(v => v !== value);
                updateSelectedFilters();
            }
        }

        function handleAutocompleteKeydown(event, type) {
            if (event.key === 'Escape') {
                const dropdowns = ['conceptAutocomplete', 'discourseAutocomplete', 'scriptureAutocomplete', 'entityAutocomplete'];
                dropdowns.forEach(id => document.getElementById(id).classList.remove('show'));
            }
        }

        async function applyFilters() {
            const loading = document.getElementById('draftSourcesContent');
            loading.innerHTML = '<div class="loading"><div class="spinner"></div> Filtering chunks...</div>';

            try {
                const response = await fetch('/api/filter-chunks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filters: selectedFilters })
                });

                if (response.ok) {
                    const data = await response.json();
                    // Format data for display
                    displayDraftSearchResults({
                        sources_used: data.sources_used,
                        chunks: data.sources_used.map(s => ({
                            text: s.text,
                            metadata: s.metadata,
                            source: s.source,
                            author: s.author
                        }))
                    });
                } else {
                    loading.innerHTML = '<div class="error">Error applying filters</div>';
                }
            } catch (error) {
                console.error('Error applying filters:', error);
                loading.innerHTML = '<div class="error">Error applying filters</div>';
            }
        }

        function clearFilters() {
            selectedFilters = {
                sources: [],
                authors: [],
                concepts: [],
                topics: [],
                terms: [],
                discourse_elements: [],
                scripture_references: [],
                named_entities: []
            };
            
            // Clear checkboxes
            document.querySelectorAll('#sourceFilters input[type="checkbox"]').forEach(cb => cb.checked = false);
            document.querySelectorAll('#authorFilters input[type="checkbox"]').forEach(cb => cb.checked = false);
            
            // Clear autocomplete inputs
            document.getElementById('conceptFilterInput').value = '';
            document.getElementById('discourseFilterInput').value = '';
            document.getElementById('scriptureFilterInput').value = '';
            document.getElementById('entityFilterInput').value = '';
            
            // Clear dropdowns
            ['conceptAutocomplete', 'discourseAutocomplete', 'scriptureAutocomplete', 'entityAutocomplete'].forEach(id => {
                document.getElementById(id).classList.remove('show');
            });
            
            // Clear selected tags
            updateSelectedFilters();
            
            // Clear results
            document.getElementById('draftSourcesContent').innerHTML = '<div class="no-results">No filters applied</div>';
        }

        // Close autocomplete dropdowns when clicking outside
        document.addEventListener('click', (event) => {
            // Don't close if clicking inside autocomplete dropdown
            if (event.target.closest('.autocomplete-dropdown')) {
                return;
            }
            // Close all dropdowns if clicking outside filter sections
            if (!event.target.closest('.filter-section')) {
                ['conceptAutocomplete', 'discourseAutocomplete', 'scriptureAutocomplete', 'entityAutocomplete'].forEach(id => {
                    document.getElementById(id).classList.remove('show');
                });
            }
        });

        function copyToClipboard(event) {
            const btn = event.target;
            const textToCopy = decodeURIComponent(btn.getAttribute('data-text') || '');
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Show brief feedback
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = '#d4edda';
                btn.style.color = '#155724';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#f0f0f0';
                    btn.style.color = '#666';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        function performSearch() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query) {
                alert('Please enter a research question');
                return;
            }

            if (selectedSources.size === 0) {
                alert('Please select at least one source');
                return;
            }

            const searchBtn = document.getElementById('searchBtn');
            const loading = document.getElementById('loading');
            const mainContent = document.getElementById('mainContent');

            // Show loading state
            searchBtn.disabled = true;
            loading.style.display = 'block';
            document.getElementById('layoutContainer').style.display = 'none';
            document.getElementById('mainContent').style.display = 'none';

            // Prepare request data
            const requestData = {
                query: query,
                sources: Array.from(selectedSources)
            };

            // Make API request
            fetch('/search', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                currentSearchResult = data;
                displaySearchResults(data);
                document.getElementById('saveSearchBtn').disabled = false;
            })
            .catch(error => {
                console.error('Search error:', error);
                document.getElementById('researchContent').innerHTML = `
                    <div class="error">Error: ${error.message}</div>
                `;
                mainContent.style.display = 'grid';
            })
            .finally(() => {
                searchBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function displaySearchResults(data) {
            const researchContent = document.getElementById('researchContent');
            const sourcesContent = document.getElementById('sourcesContent');
            const mainContent = document.getElementById('mainContent');

            // Display reasoning section
            let reasoningHtml = '';
            if (data.reasoning_transparency) {
                reasoningHtml = `
                    <div class="reasoning-section">
                        <div class="reasoning-title">Search Strategy</div>
                        <div class="reasoning-text">${data.reasoning_transparency}</div>
                    </div>
                `;
            }

            // Parse markdown and add clickable citations
            const parsedMarkdown = parseMarkdown(data.summary);
            const summaryWithCitations = addCitationClickHandlers(parsedMarkdown);
            researchContent.innerHTML = reasoningHtml + `
                <div class="summary">${summaryWithCitations}</div>
            `;

            // Store sources for citation handling
            currentSources = data.sources_used || [];

            // Display sources
            let sourcesHtml = '';
            if (currentSources.length > 0) {
                sourcesHtml = currentSources.map((source, index) => {
                    const sourceNumber = index + 1;
                    const chunkText = findSourceText(sourceNumber, data.chunks);
                    
                    // Build metadata tooltip
                    const metadata = source.metadata || {};
                    let tooltipContent = '';
                    
                    if (metadata.topics && metadata.topics.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Topics</div><div class="metadata-values">${metadata.topics.join(', ')}</div></div>`;
                    }
                    if (metadata.concepts && metadata.concepts.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Concepts</div><div class="metadata-values">${metadata.concepts.join(', ')}</div></div>`;
                    }
                    if (metadata.terms && metadata.terms.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Terms</div><div class="metadata-values">${metadata.terms.join(', ')}</div></div>`;
                    }
                    if (metadata.discourse_elements && metadata.discourse_elements.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Discourse Elements</div><div class="metadata-values">${metadata.discourse_elements.join(', ')}</div></div>`;
                    }
                    if (metadata.scripture_references && metadata.scripture_references.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Scripture References</div><div class="metadata-values">${metadata.scripture_references.join(', ')}</div></div>`;
                    }
                    if (metadata.named_entities && metadata.named_entities.length > 0) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Named Entities</div><div class="metadata-values">${metadata.named_entities.join(', ')}</div></div>`;
                    }
                    if (metadata.structure_path) {
                        tooltipContent += `<div class="metadata-section"><div class="metadata-label">Location</div><div class="metadata-values">${metadata.structure_path}</div></div>`;
                    }

                    return `
                        <div class="source-item" id="source-${sourceNumber}">
                            <div class="source-header">
                                <div class="source-number">${sourceNumber}</div>
                                <div class="source-title">${source.source || 'Unknown Source'}</div>
                                ${tooltipContent ? `
                                <div class="metadata-tooltip">
                                    <span style="cursor: help; color: #666;">â“˜</span>
                                    <div class="tooltip-content">${tooltipContent}</div>
                                </div>
                                ` : ''}
                            </div>
                            <div class="source-meta">
                                ${source.author ? `Author: ${source.author}` : ''}
                                ${source.location && source.location !== 'Unknown' ? ` â€¢ Location: ${source.location}` : ''}
                            </div>
                            <div class="source-text">${chunkText}</div>
                            ${source.relevance_explanation ? `
                                <div class="source-relevance">
                                    <strong>Why this source:</strong> ${source.relevance_explanation}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            } else {
                sourcesHtml = '<div class="no-results">No sources found</div>';
            }

            sourcesContent.innerHTML = sourcesHtml;
            
            // Show research layout
            document.getElementById('layoutContainer').style.display = 'flex';
            document.getElementById('researchLayout').style.display = 'grid';
            document.getElementById('draftLayout').style.display = 'none';
            
            // Ensure normal grid layout when displaying results
            const researchLayout = document.getElementById('researchLayout');
            researchLayout.style.gridTemplateColumns = '2fr 1fr 200px';
            const researchPanel = researchLayout.children[0];
            const sourcesPanel = researchLayout.children[1];
            researchPanel.style.display = 'block';
            sourcesPanel.style.display = 'block';
        }

        function parseMarkdown(text) {
            if (!text) return '';
            
            let html = text;
            
            // First, protect citations from being processed (both [1] and (1) formats)
            // Use a unique placeholder pattern that won't conflict with markdown syntax
            const citationPlaceholders = [];
            // Handle parentheses citations (1)
            html = html.replace(/\((\d+)\)/g, (match, num) => {
                const placeholder = `{{CITATION_${citationPlaceholders.length}}}`;
                citationPlaceholders.push(match);
                return placeholder;
            });
            // Handle square bracket citations [1]
            html = html.replace(/\[(\d+)\]/g, (match, num) => {
                const placeholder = `{{CITATION_${citationPlaceholders.length}}}`;
                citationPlaceholders.push(match);
                return placeholder;
            });
            
            // Convert bold first (**text** or __text__) - but not in list contexts
            // We'll do this after lists to avoid interfering
            
            // Convert headers (###, ##, #) - but skip if inside a list context
            // Process h3 first, then h2, then h1
            // Headers on their own lines won't interfere with lists
            
            // Convert numbered lists (1. item)
            // First, find all lines that start with number patterns
            const lines = html.split('\n');
            let inNumberedList = false;
            let numberedListItems = [];
            let processedLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const numberedMatch = line.match(/^(\d+)\.\s+(.+)$/);
                
                if (numberedMatch) {
                    if (!inNumberedList) {
                        // Start new list
                        inNumberedList = true;
                        numberedListItems = [];
                    }
                    numberedListItems.push(numberedMatch[2]);
                } else {
                    // Check if this is a continuation of previous list item
                    if (inNumberedList && line.trim() && !line.match(/^(<|#|-|\*|\d+\.)/)) {
                        // Append to last list item
                        if (numberedListItems.length > 0) {
                            numberedListItems[numberedListItems.length - 1] += ' ' + line.trim();
                        }
                    } else {
                        // End current list if any
                        if (inNumberedList) {
                            const listHtml = '<ol>' + numberedListItems.map(item => `<li>${item}</li>`).join('') + '</ol>';
                            processedLines.push(listHtml);
                            numberedListItems = [];
                            inNumberedList = false;
                        }
                        processedLines.push(line);
                    }
                }
            }
            
            // Close any open list at the end
            if (inNumberedList && numberedListItems.length > 0) {
                const listHtml = '<ol>' + numberedListItems.map(item => `<li>${item}</li>`).join('') + '</ol>';
                processedLines.push(listHtml);
            }
            
            html = processedLines.join('\n');
            
            // Convert bullet lists (- item or * item) - similar approach
            const bulletLines = html.split('\n');
            let inBulletList = false;
            let bulletListItems = [];
            let processedBulletLines = [];
            
            for (let i = 0; i < bulletLines.length; i++) {
                const line = bulletLines[i];
                const bulletMatch = line.match(/^[-*]\s+(.+)$/);
                
                if (bulletMatch) {
                    if (!inBulletList) {
                        inBulletList = true;
                        bulletListItems = [];
                    }
                    bulletListItems.push(bulletMatch[1]);
                } else {
                    if (inBulletList && line.trim() && !line.match(/^(<|#|-|\*|\d+\.)/)) {
                        if (bulletListItems.length > 0) {
                            bulletListItems[bulletListItems.length - 1] += ' ' + line.trim();
                        }
                    } else {
                        if (inBulletList) {
                            const listHtml = '<ul>' + bulletListItems.map(item => `<li>${item}</li>`).join('') + '</ul>';
                            processedBulletLines.push(listHtml);
                            bulletListItems = [];
                            inBulletList = false;
                        }
                        processedBulletLines.push(line);
                    }
                }
            }
            
            if (inBulletList && bulletListItems.length > 0) {
                const listHtml = '<ul>' + bulletListItems.map(item => `<li>${item}</li>`).join('') + '</ul>';
                processedBulletLines.push(listHtml);
            }
            
            html = processedBulletLines.join('\n');
            
            // Now convert headers (###, ##, #) - but skip headers that are part of numbered lists
            // Handle numbered list items that start with headers like "#### 6. Text" first
            html = html.replace(/^####\s+(\d+)\.\s+(.+)$/gm, '<li><strong>$2</strong></li>');
            html = html.replace(/^###\s+(\d+)\.\s+(.+)$/gm, '<li><strong>$2</strong></li>');
            html = html.replace(/^##\s+(\d+)\.\s+(.+)$/gm, '<li><strong>$2</strong></li>');
            html = html.replace(/^#\s+(\d+)\.\s+(.+)$/gm, '<li><strong>$2</strong></li>');
            
            // Now convert regular headers (that don't start with numbers)
            html = html.replace(/^####\s+(?!\d+\.\s)(.+)$/gm, '<h4>$1</h4>');
            html = html.replace(/^###\s+(?!\d+\.\s)(.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^##\s+(?!\d+\.\s)(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#\s+(?!\d+\.\s)(.+)$/gm, '<h1>$1</h1>');
            
            // Convert bold (**text** or __text__) - can appear anywhere now
            // But make sure we don't match citation placeholders
            html = html.replace(/\*\*([^*\n]+)\*\*/g, '<strong>$1</strong>');
            // Only match __text__ if it's not part of a citation placeholder
            html = html.replace(/__([^_\n{]+)__/g, '<strong>$1</strong>');
            
            // Split into paragraphs (double newlines or single newline after block elements)
            // First, replace double newlines with paragraph markers
            html = html.replace(/\n\n+/g, '\n\nPARAGRAPH_BREAK\n\n');
            
            // Split and process
            const parts = html.split(/\n\nPARAGRAPH_BREAK\n\n/);
            html = parts.map(p => {
                p = p.trim();
                // Don't wrap if it's already a tag (heading, list) or starts with HTML
                if (p.match(/^<(h[1-6]|ol|ul|li|p)/)) {
                    return p;
                }
                // If it contains block-level HTML tags, don't wrap
                if (p.includes('<ol>') || p.includes('<ul>') || p.includes('<h')) {
                    return p;
                }
                if (p) {
                    return `<p>${p}</p>`;
                }
                return '';
            }).join('\n\n');
            
            // Restore citations from placeholders and make them clickable
            citationPlaceholders.forEach((citation, index) => {
                // Replace placeholder with clickable citation
                // Try to match both formats: parentheses (1) and square brackets [1]
                const citationNumParentheses = citation.match(/\((\d+)\)/);
                const citationNumBrackets = citation.match(/\[(\d+)\]/);
                const citationNum = citationNumParentheses || citationNumBrackets;
                if (citationNum) {
                    const num = citationNum[1];
                    // Escape curly braces in regex
                    const placeholderPattern = `\\{\\{CITATION_${index}\\}\\}`;
                    // Preserve original format (parentheses or brackets)
                    const formattedCitation = citationNumParentheses 
                        ? `(${num})` 
                        : `[${num}]`;
                    html = html.replace(new RegExp(placeholderPattern, 'g'), 
                        `<span class="citation" onclick="scrollToSource(${num})">${formattedCitation}</span>`);
                } else {
                    // Fallback: just restore the original citation
                    const placeholderPattern = `\\{\\{CITATION_${index}\\}\\}`;
                    html = html.replace(new RegExp(placeholderPattern, 'g'), citation);
                }
            });
            
            return html;
        }

        function addCitationClickHandlers(summary) {
            // This function is now mostly redundant since citations are handled in parseMarkdown
            // But keep it for any citations that weren't protected as placeholders
            // Handle both parentheses (1) and square brackets [1]
            summary = summary.replace(/\((\d+)\)/g, '<span class="citation" onclick="scrollToSource($1)">($1)</span>');
            summary = summary.replace(/\[(\d+)\]/g, '<span class="citation" onclick="scrollToSource($1)">[$1]</span>');
            return summary;
        }

        function scrollToSource(sourceNumber) {
            const sourceElement = document.getElementById(`source-${sourceNumber}`);
            if (sourceElement) {
                // Remove previous highlights
                document.querySelectorAll('.source-item').forEach(item => {
                    item.classList.remove('highlighted');
                });
                
                // Highlight and scroll to source
                sourceElement.classList.add('highlighted');
                sourceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    sourceElement.classList.remove('highlighted');
                }, 3000);
            }
        }

        function findSourceText(sourceNumber, chunks) {
            // Find the chunk text for this source number
            if (!chunks || chunks.length === 0) {
                return 'Text not available';
            }
            
            // Get the source info for this number
            const sourceInfo = currentSources[sourceNumber - 1];
            if (!sourceInfo) {
                return 'Text not available';
            }
            
            // Try to find chunk by matching _chunk_index value (not using it as array index)
            // This works for both fresh searches and loaded history
            if (sourceInfo._chunk_index !== undefined && sourceInfo._chunk_index >= 0) {
                const chunk = chunks.find(c => c._chunk_index === sourceInfo._chunk_index);
                if (chunk && chunk.text) {
                    return chunk.text;
                }
            }
            
            // Fallback 1: Match by chunk_id if available
            if (sourceInfo.chunk_id) {
                const chunk = chunks.find(c => c.id === sourceInfo.chunk_id);
                if (chunk && chunk.text) {
                    return chunk.text;
                }
            }
            
            // Fallback 2: If sources have the same order as chunks, try array index
            // This is a last resort for backwards compatibility
            if (sourceInfo._chunk_index !== undefined && 
                sourceInfo._chunk_index >= 0 && 
                sourceInfo._chunk_index < chunks.length) {
                const chunk = chunks[sourceInfo._chunk_index];
                if (chunk && chunk.text) {
                    return chunk.text;
                }
            }
            
            // Fallback 3: Return a placeholder
            return 'Source text unavailable';
        }
    </script>
</body>
</html>